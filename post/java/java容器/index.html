<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Java容器 - P1n93r - 博学而精一</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Pinger"><meta name=description content="概览 Java容器主要包括Collection和Map两种，Collection存储对象集合，而Map存储键值对（两个对象）的映射表。 Collection Set Tr"><meta name=keywords content="Security,Java,Web,Android"><meta name=generator content="Hugo 0.98.0 with theme even"><link rel=canonical href=https://p1n93r.github.io/post/java/java%E5%AE%B9%E5%99%A8/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Java容器"><meta property="og:description" content="概览 Java容器主要包括Collection和Map两种，Collection存储对象集合，而Map存储键值对（两个对象）的映射表。 Collection Set Tr"><meta property="og:type" content="article"><meta property="og:url" content="https://p1n93r.github.io/post/java/java%E5%AE%B9%E5%99%A8/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-05-12T10:21:36+08:00"><meta property="article:modified_time" content="2020-05-12T10:21:36+08:00"><meta itemprop=name content="Java容器"><meta itemprop=description content="概览 Java容器主要包括Collection和Map两种，Collection存储对象集合，而Map存储键值对（两个对象）的映射表。 Collection Set Tr"><meta itemprop=datePublished content="2020-05-12T10:21:36+08:00"><meta itemprop=dateModified content="2020-05-12T10:21:36+08:00"><meta itemprop=wordCount content="7444"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Java容器"><meta name=twitter:description content="概览 Java容器主要包括Collection和Map两种，Collection存储对象集合，而Map存储键值对（两个对象）的映射表。 Collection Set Tr"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>P1n93r</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>P1n93r</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Java容器</h1><div class=post-meta><span class=post-time>2020-05-12</span><div class=post-category><a href=/categories/java/>Java</a></div><span class=more-meta>约 7444 字</span>
<span class=more-meta>预计阅读 15 分钟</span>
<span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次阅读</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#概览>概览</a><ul><li><a href=#collection>Collection</a></li><li><a href=#map>Map</a></li></ul></li><li><a href=#容器中的设计模式>容器中的设计模式</a><ul><li><a href=#迭代器模式>迭代器模式</a></li><li><a href=#适配器模式>适配器模式</a></li></ul></li><li><a href=#源码分析>源码分析</a><ul><li><a href=#arraylist>ArrayList</a></li><li><a href=#vector>Vector</a></li><li><a href=#copyonwritearraylist>CopyOnWriteArrayList</a></li><li><a href=#linkedlist>LinkedList</a></li><li><a href=#hashmap>HashMap</a></li><li><a href=#concurrenthashmap>ConcurrentHashMap</a></li><li><a href=#linkedhashmap>LinkedHashMap</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=概览>概览</h2><p>Java容器主要包括Collection和Map两种，Collection存储对象集合，而Map存储键值对（两个对象）的映射表。</p><h3 id=collection>Collection</h3><p><img src=/media/20200512-1.png alt=Collection关系图></p><h4 id=set>Set</h4><ul><li>TreeSet：基于红黑树实现，支持有序性操作（通过其实现SortedSet接口也可看出）。但是查询效率不如HashSet，HashSet查找时间复杂度为O(1)，而TreeSet则为O(logN)。</li><li>HashSet：基于哈希表实现，支出快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息。</li><li>LinkedHashSet：具有HashSet的查找效率，并且内部使用双向链表维护元素的插入顺序。</li></ul><h4 id=list>List</h4><ul><li>ArrayList：基于动态数组实现，支持随机访问。</li><li>Vector：和ArrayList类似，但是它是线程安全的。</li><li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速的在链表中插入和删除。不仅如此，LinkedList还可以用作<strong>栈、队列和双向队列</strong> 。</li></ul><h4 id=queue>Queue</h4><ul><li>LinkedList：可以用它来实现双向队列。</li><li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li></ul><h3 id=map>Map</h3><p><img src=/media/20200512-2.png alt=Map关系图></p><ul><li>TreeMap：基于红黑树实现。</li><li>HashMap：基于哈希表实现。</li><li>HashTable：和HashMap类似，但是它是线程安全的， <strong>这意味着同一时刻多个线程同时写入HashTable不会导致数据不一致</strong> 。但是它是遗留类，不应该去使用它，而是使用ConcurrentHashMap来支持线程安全，ConcurrentHashMap的效率会更高，因为ConcurrentHashMap引入和分段锁。</li><li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用顺序。</li></ul><h2 id=容器中的设计模式>容器中的设计模式</h2><h3 id=迭代器模式>迭代器模式</h3><p><img src=/media/20200512-3.png alt=迭代器></p><p>Collection继承了Iterable接口，其中的iterator()方法能够产生一个Iterator对象，通过这个对象就可迭代遍历Collection中的元素。</p><p>从JDK1.5之后就可以使用foreach方法来遍历实现了Iterable接口的聚合对象。例如：</p><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add(&quot;笨笨&quot;);
list.add(&quot;蠢蠢&quot;);
for (String v:list){
	System.out.println(v);
}
</code></pre><h3 id=适配器模式>适配器模式</h3><p>java.util.Arrays.asList()可以把数组类型转换成List类型。需要注意的事，asList()参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p><p>asList()的实现代码如下：</p><pre><code>@SafeVarargs
@SuppressWarnings(&quot;varargs&quot;)
public static &lt;T&gt; List&lt;T&gt; asList(T... a) {
    return new ArrayList&lt;&gt;(a);
}
</code></pre><p>调用asList()的两种方式如下：</p><pre><code>//方式一
Integer[] args={1,2,3};
List&lt;Integer&gt; integers = Arrays.asList(args);
//方式二
List&lt;String&gt; strings = Arrays.asList(&quot;1&quot;, &quot;2&quot;);
</code></pre><h2 id=源码分析>源码分析</h2><p>没有特殊说明都是基于JDK 1.8的源码。</p><h3 id=arraylist>ArrayList</h3><h4 id=概览-1>概览</h4><p>因为ArrayList是基于数组实现的，所以支持快速随机访问。RandomAccess接口标识着该类支持快速随机访问。</p><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
</code></pre><p>数组的默认大小为10.</p><pre><code>/**
 * Default initial capacity.
 */
private static final int DEFAULT_CAPACITY = 10;
</code></pre><p><img src=/media/20200513-1.png alt=ArrayList存储结构></p><h4 id=扩容>扩容</h4><p>添加元素时使用ensureCapacityInternal()方法来保证容量足够，如果不够，需要使用grow()方法来进行扩容，新容量的大小为旧容量的1.5倍（一般情况下）。</p><p>同时，扩容需要调用Arrays.copyOf()把原始数组整个复制到新数组中，这个操作代价很高， <strong>因此最好在创建ArrayList对象时就指定大概容量的大小，减少扩容的次数</strong> 。</p><p>扩容部分源码如下：</p><pre><code>public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}

private static int hugeCapacity(int minCapacity) {
    if (minCapacity &lt; 0) // overflow
        throw new OutOfMemoryError();
    return (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
}
</code></pre><h4 id=删除>删除</h4><p>需要调用System.arraycopy()将index+1后面的元素都复制到index位置上，该操作的时间复杂度为O(n)，ArrayList删除元素的代价是非常高的。</p><pre><code>public E remove(int index) {
    rangeCheck(index);
    modCount++;
    E oldValue = elementData(index);
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; // clear to let GC do its work
    return oldValue;
}
</code></pre><h4 id=序列化>序列化</h4><p>ArrayList基于数组实现，并且具有动态扩展的特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p><p>保存元素的数组elementData使用 <code>transient</code> 修饰， <strong>该关键字声明数组默认不会被序列化</strong> 。</p><pre><code>transient Object[] elementData; // non-private to simplify nested class access
</code></pre><p>ArrayList实现了writeObject()和readObject()来控制只序列化数组中有元素填充的那部分的内容。</p><pre><code>private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size &gt; 0) {
        // be like clone(), allocate array based upon size not capacity
        ensureCapacityInternal(size);

        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i&lt;size; i++) {
            a[i] = s.readObject();
        }
    }
}

private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i&lt;size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
</code></pre><p>序列化时需要使用ObjectOutputStream的writeObject()将对象装换为字节流并输出。而writeObject()方法在传入的对象存在writeObject()方法的时候会反射调用该对象的writeObject()来实现序列化。反序列化使用的是ObjectInputStream的readObject()方法，原理类似。</p><h4 id=fail-fast>Fail-Fast</h4><p>modCount用来记录ArrayList结构发生变化的次数。结构发生变化是指：添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅是设置元素的值不算结构发生了变化。</p><p><strong>在进行序列化或者迭代等操作时，需要比较操作前后的modCount是否发生了变化</strong> ，如果发生了变化，则需要抛出ConcurrentModicationException。例如上面的writeObject()方法。</p><h3 id=vector>Vector</h3><h4 id=同步>同步</h4><p>它的实现与ArrayList类型，但是使用了关键字 <strong>synchronize</strong> 进行同步。</p><pre><code>public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

public synchronized E get(int index) {
    if (index &gt;= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}
</code></pre><h4 id=扩容-1>扩容</h4><p>Vector的构造函数可以传入capacityIncreament参数，它的作用是在扩容时使容量capacity增长capacityIncreament。如果这个参数的值小于等于0，扩容时每次都令capacity为原来的 <strong>两倍</strong> 。</p><pre><code>public Vector(int initialCapacity, int capacityIncrement) {
    super();
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement = capacityIncrement;
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre><p>调用没有capacityIncreament的构造函数时，capacityIncreament值被设置为0，也就是说默认情况下Vector每次扩容时容量都会翻倍。</p><pre><code>public Vector(int initialCapacity) {
    this(initialCapacity, 0);
}

public Vector() {
    this(10);
}
</code></pre><h4 id=与arraylist的比较>与ArrayList的比较</h4><ul><li>Vetor是同步的，因此开销比ArrayList大，访问速度要更加慢。最好使用ArrayList而不是Vector，因为同步操作完全可以由程序员自己来控制。</li><li>Vector每次扩容（默认情况下）请求其大小的2倍（也可以通过构造函数设置增长的容量），而ArrayList是1.5倍。</li></ul><h4 id=替代方案>替代方案</h4><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的ArrayList。</p><pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
List&lt;Integer&gt; synList = Collections.synchronizedList(list);
</code></pre><p>也可以使用concurrent并发包下的 <code>CopyOnWriteArrayList</code> 类。</p><pre><code>List&lt;String&gt; list=new CopyOnWriteArrayList&lt;&gt;();
</code></pre><h3 id=copyonwritearraylist>CopyOnWriteArrayList</h3><h4 id=读写分离>读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><pre><code>public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

final void setArray(Object[] a) {
    array = a;
}

@SuppressWarnings(&quot;unchecked&quot;)
private E get(Object[] a, int index) {
    return (E) a[index];
}

/**
 * {@inheritDoc}
 *
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E get(int index) {
    return get(getArray(), index);
}
</code></pre><h4 id=适用场景>适用场景</h4><p>CopyOnWriteArrayList在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。但是CopyOnWriteArrayList有如下缺陷：</p><ul><li>内容占用：在写操作时需要复制一个新的数组，使得内容占用为原来的两倍左右。</li><li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li></ul><p>所以CopyOnWriteArrayList不适合内容敏感以及对实时性要求很高的场景。</p><h3 id=linkedlist>LinkedList</h3><h4 id=概览-2>概览</h4><p>基于双向链表实现，使用Node存储链表节点信息。</p><pre><code>private static class Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;
}
</code></pre><p>每个链表存储了first和last指针：</p><pre><code>transient Node&lt;E&gt; first;
transient Node&lt;E&gt; last;
</code></pre><p><img src=/media/20200513-2.png alt=LinkedList存储结构></p><h4 id=与arraylist的比较-1>与ArrayList的比较</h4><p>ArrayList基于动态数组实现，而LinkedList基于双线链表实现。ArrayList和LinkedList的区别可以归结为数组和链表的区别：</p><ul><li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素。</li><li>链表不支持随机访问，但插入删除只需要改变指针。</li></ul><h3 id=hashmap>HashMap</h3><p>以下源码分析以JDK 1.7为主。</p><h4 id=存储结构>存储结构</h4><p>内部包含了一个Entry类型的数组table。Entry存储着键值对。它包含了四个字段，从next字段可以看出 <strong>Entry是一个链表</strong> 。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap使用 <strong>拉链法</strong> 来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的Entry。</p><p><img src=/media/20200513-3.png alt=HashMap存储结构></p><pre><code>transient Entry[] table;

static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final K key;
    V value;
    Entry&lt;K,V&gt; next;
    int hash;

    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }

    public final K getKey() {
        return key;
    }

    public final V getValue() {
        return value;
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry e = (Map.Entry)o;
        Object k1 = getKey();
        Object k2 = e.getKey();
        if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {
            Object v1 = getValue();
            Object v2 = e.getValue();
            if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))
                return true;
        }
        return false;
    }

    public final int hashCode() {
        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
    }

    public final String toString() {
        return getKey() + &quot;=&quot; + getValue();
    }
}
</code></pre><h4 id=拉链法的工作原理>拉链法的工作原理</h4><p>举例如下：</p><pre><code>HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;K1&quot;, &quot;V1&quot;);
map.put(&quot;K2&quot;, &quot;V2&quot;);
map.put(&quot;K3&quot;, &quot;V3&quot;);
</code></pre><ul><li>新建一个HashMap，默认大小为16。</li><li>插入&lt;K1,V1>键值对，先计算K1的hashCode为115，使用除留余数法得到所在的桶下标115%16=3。</li><li>插入&lt;K2,V2>键值对，先计算K2的hashCode为118，使用除留余数法得到所在的桶下标118%16=6。</li><li>插入&lt;K3,V3>键值对，先计算K3的hashCode为118，使用除留余数法得到所在的桶下标118%16=6，插在&lt;K2,V2>前面。</li></ul><p><em><strong>Notice：</strong></em> 链表的插入是以头插法进行的，例如上面的&lt;K3,V3>不是插在&lt;K2,V2>后面，而是插在链表头部。</p><p>查找需要分两步：</p><ol><li>计算键值对所在的桶。</li><li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li></ol><p><img src=/media/20200513-4.png alt=拉链法工作原理></p><h4 id=put操作>put操作</h4><pre><code>public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    // 键为 null 单独处理
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    // 确定桶下标
    int i = indexFor(hash, table.length);
    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    // 插入新键值对
    addEntry(hash, key, value, i);
    return null;
}
</code></pre><p><strong>HashMap允许插入键为null的键值对。</strong> 但是因为无法调用null的hashCode()方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap使用第0个桶存放键为null的键值对。</p><pre><code>private V putForNullKey(V value) {
    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {
        if (e.key == null) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;
    addEntry(0, null, value, 0);
    return null;
}
</code></pre><p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p><pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}

void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    // 头插法，链表头部指向新的键值对
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    size++;
}

Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
    value = v;
    next = n;
    key = k;
    hash = h;
}
</code></pre><h4 id=确定桶下标>确定桶下标</h4><p>很多操作都要先确定一个键值对的所在桶的下标，分为如下两步：</p><pre><code>int hash=hash(key);
int i=indexFor(hash,table.length);
</code></pre><h5 id=计算hash值>计算hash值</h5><pre><code>final int hash(Object k) {
    int h = hashSeed;
    if (0 != h &amp;&amp; k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();

    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}

public final int hashCode() {
    return Objects.hashCode(key) ^ Objects.hashCode(value);
}
</code></pre><h5 id=取模>取模</h5><p>令x=1&#171;4，即x为2的4此方。令一个数y与x-1做与运算，可以去除y位级表示的第4位以上数：</p><pre><code>y       : 10110010
x-1     : 00001111
y&amp;(x-1) : 00000010
</code></pre><p>这个性质和y对x取模效果是一样的：</p><pre><code>y   : 10110010
x   : 00010000
y%x : 00000010
</code></pre><p>而位运算的代价比求模运算小得多，因此在进行这种计算用位运算能带来更高的性能。确定桶的下标的最后一步就是将key的hash值对桶个数取模：hash%capacity，如果能保证capacity为2的n次方，那么就可以将这个取模操作转换成与操作。</p><pre><code>static int indexFor(int h, int length) {
    return h &amp; (length-1);
}
</code></pre><h4 id=扩容基本原理>扩容基本原理</h4><p>设HashMap的table的长度为M，需要存储的键值对数量为N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为N/M，因此查找的复杂度为O(N/M)。为了让查找成本降低，应该是N/M尽可能小，因此需要保证M尽可能的大，也就是说table要尽可能大。HashMap采用动态扩容来根据当前的N值来调整M值，是的空间效率和时间效率得到保证。</p><p>和扩容有关的参数主要有：capacity、size、threshold和load_factor：</p><table><thead><tr><th style=text-align:center>参数</th><th style=text-align:center>含义</th></tr></thead><tbody><tr><td style=text-align:center>capacity</td><td style=text-align:center>table的容量大小，默认为16。需要注意的是： <strong>capacity必须为2的n次方</strong></td></tr><tr><td style=text-align:center>size</td><td style=text-align:center>键值对的数量</td></tr><tr><td style=text-align:center>threshold</td><td style=text-align:center>size的阈值，当size大于等于threshold就必须进行扩容</td></tr><tr><td style=text-align:center>loadFactor</td><td style=text-align:center>装载因子，table能够使用的比例，threshold=(int)(capacity*loadFactor)</td></tr></tbody></table><p>相关源码如下：</p><pre><code>static final int DEFAULT_INITIAL_CAPACITY = 16;

static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

static final float DEFAULT_LOAD_FACTOR = 0.75f;

transient Entry[] table;

transient int size;

int threshold;

final float loadFactor;

transient int modCount;
</code></pre><p>从下面的代码可看出，当需要扩容时，令capacity为原来的两倍：</p><pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    if (size++ &gt;= threshold)
        resize(2 * table.length);
}
</code></pre><p>扩容使用resize()实现，需要注意的是扩容同样需要把oldTable的所有键值对重新插入到newTable中，因此这一步是很费时的。</p><pre><code>void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }
    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable);
    table = newTable;
    threshold = (int)(newCapacity * loadFactor);
}

void transfer(Entry[] newTable) {
    Entry[] src = table;
    int newCapacity = newTable.length;
    for (int j = 0; j &lt; src.length; j++) {
        Entry&lt;K,V&gt; e = src[j];
        if (e != null) {
            src[j] = null;
            do {
                Entry&lt;K,V&gt; next = e.next;
                int i = indexFor(e.hash, newCapacity);
				//头插法
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null);
        }
    }
}
</code></pre><h4 id=扩容重新计算桶下标>扩容重新计算桶下标</h4><p>在进行扩容时，需要把键值对重新计算桶下标，从而放在对应的桶上。HashMap使用hash%capacity来确定桶下标（确保capacity为2的n次方，便使用hash&(capacity-1)同等替换）。</p><p>假设原数组长度capacity为16，扩容后new capacity为32：</p><pre><code>capacity     : 00010000
new capacity : 00100000
</code></pre><p>此时观察hash值的第5位，如果第5位为0，则桶位置和原来一样，如果为1，则在原位置加2^5=16。</p><h4 id=计算数组容量>计算数组容量</h4><p>HashMap构造函数允许用户传入的容量不是2的n次方，因为它可以自动地将传入的容量转换为2的n次方。</p><p>现在存在一个定理： <strong>大于某个数的最小的2的n次方，为此数的掩码加1</strong> 。那么如果计算一个数的掩码呢，例如对于10010000，它的掩码是11111111，可以使用如下方法得到其掩码：</p><pre><code>mask |= mask &gt;&gt; 1    11011000
mask |= mask &gt;&gt; 2    11111110
mask |= mask &gt;&gt; 4    11111111
</code></pre><p>那么mask+1就是 <strong>大于</strong> 原始数据的最小2的n次方：</p><pre><code>num     10010000
mask+1 100000000
</code></pre><p>以下是HashMap中计算数组容量的代码：</p><pre><code>static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre><p><em><strong>Notice:</strong></em> tableSizeFor()函数一开始将cap-1，是因为如果不减一最终得到的是一个 <strong>大于</strong> cap的最小的2的n次方，首先将cap-1，就能够得到 <strong>大于等于</strong> cap的最小的2的n次方了。</p><h4 id=链表转为红黑树>链表转为红黑树</h4><p>从JDK 1.8开始，一个桶存储的链表长度大于等于8时将会将链表转为红黑树。</p><h4 id=与hashtable的比较>与HashTable的比较</h4><ul><li>HashTable使用synchronized来进行同步。</li><li>HashMap可以插入键为null的Entry。</li><li>HashMap的迭代器是fail-fast迭代器。</li><li>HashMap不能保证随着时间的推移Map中的元素次序是不变的。</li></ul><h3 id=concurrenthashmap>ConcurrentHashMap</h3><h4 id=存储结构-1>存储结构</h4><pre><code>static final class HashEntry&lt;K,V&gt; {
    final int hash;
    final K key;
    volatile V value;
    volatile HashEntry&lt;K,V&gt; next;
}
</code></pre><p>ConcurrentHashMap和HashMap实现上类似，最主要的区别是ConcurrentHashMap采用了 <strong>分段锁(Segment)</strong> ，每个分段锁维护着几个桶(HashEntry)，多线程可以同时访问不同分段锁上的桶，从而使得其并发度更高（并发度就是Segment的个数）。</p><p>Segment继承自ReentrantLock：</p><pre><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {

    private static final long serialVersionUID = 2249069246763182397L;

    static final int MAX_SCAN_RETRIES =
        Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;

    transient volatile HashEntry&lt;K,V&gt;[] table;

    transient int count;

    transient int modCount;

    transient int threshold;

    final float loadFactor;
}
</code></pre><p>默认的并发级别是16，也就是说默认创建16个Segment：</p><pre><code>final Segment&lt;K,V&gt;[] segments;
static final int DEFAULT_CONCURRENCY_LEVEL = 16;
</code></pre><p><img src=/media/20200514-1.png alt=ConcurrentHashMap存储结构图></p><h4 id=size操作>size操作</h4><p>每个Segment维护一个count变量来统计该Segment中的键值对数目。</p><pre><code>/**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 */
transient int count;
</code></pre><p>在执行size操作时，需要遍历所有的Segment然后把所有的count累计起来。ConcurrentHashMap在执行size操作的时候先尝试不加锁，如果连续两次不加锁操作得到modCount的结果一致，那么可以认为这个结果是正确的。尝试次数使用RETRIES_BEFORE_LOCK定义，该值为2，retries初始值为-1，因此尝试次数为3。如果尝试次数超过3次，就需要对每个Segment加锁。</p><pre><code>/**
 * Number of unsynchronized retries in size and containsValue
 * methods before resorting to locking. This is used to avoid
 * unbounded retries if tables undergo continuous modification
 * which would make it impossible to obtain an accurate result.
 */
static final int RETRIES_BEFORE_LOCK = 2;

public int size() {
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    final Segment&lt;K,V&gt;[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn't retry
    try {
        for (;;) {
            // 超过尝试次数，则对每个 Segment 加锁
            if (retries++ == RETRIES_BEFORE_LOCK) {
                for (int j = 0; j &lt; segments.length; ++j)
                    ensureSegment(j).lock(); // force creation
            }
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j &lt; segments.length; ++j) {
                Segment&lt;K,V&gt; seg = segmentAt(segments, j);
                if (seg != null) {
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c &lt; 0 || (size += c) &lt; 0)
                        overflow = true;
                }
            }
            // 连续两次得到modCount的结果一致，则认为这个结果是正确的
            if (sum == last)
                break;
            last = sum;
        }
    } finally {
        if (retries &gt; RETRIES_BEFORE_LOCK) {
            for (int j = 0; j &lt; segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    return overflow ? Integer.MAX_VALUE : size;
}
</code></pre><h4 id=jdk-18的改动>JDK 1.8的改动</h4><ul><li>JDK 1.7使用分段锁机制实现并发更新操作，核心类为Segment，它继承自重入锁ReentrantLock，并发度和Segment数量相等。</li><li>JDK 1.8使用了CAS操作来支持更高的并发度，在CAS操作失败时使用内置锁synchronized。</li><li>JDK 1.8的实现也在链表过长时会转换为红黑树。</li></ul><h3 id=linkedhashmap>LinkedHashMap</h3><h4 id=存储结构-2>存储结构</h4><p>继承自HashMap，因此具有和HashMap一样的快速查找特征：</p><pre><code>public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;
</code></pre><p>内部维护一个双向链表，用来维护插入顺序或者LRU顺序：</p><pre><code>/**
 * The head (eldest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; head;

/**
 * The tail (youngest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; tail;
</code></pre><p>accessOrder决定了顺序，默认为false，此时维护的是插入顺序,否则维护的就是LRU顺序。</p><pre><code>final boolean accessOrder;
</code></pre><p>LinkedHashMap最重要的是以下用于维护顺序的函数，它们会在put、get等方法中调用。</p><pre><code>void afterNodeAccess(Node&lt;K,V&gt; p) { }
void afterNodeInsertion(boolean evict) { }
</code></pre><h4 id=afternodeaccess>afterNodeAccess()</h4></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>Pinger</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2020-05-12</span></p></div><footer class=post-footer><nav class=post-nav><a class=prev href=/post/interview/%E6%B3%A8%E8%A7%A3%E9%9B%86%E5%90%88%E5%92%8C%E6%B3%9B%E5%9E%8Bjava/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">注解、集合和泛型(Java)</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/other/%E6%94%AF%E4%BB%98%E5%AE%9Deasysdk%E7%9A%84%E4%BD%BF%E7%94%A8/><span class="next-text nav-default">支付宝easySDK的使用</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname==="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="p1n93r",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:pin83r@gmail.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/p1n93r class="iconfont icon-github" title=github></a>
<a href=https://p1n93r.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次</span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv>本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人</span></div><span class=copyright-year>&copy;
2019 -
2022<span class=heart><i class="iconfont icon-heart"></i></span><span>P1n93r</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js></script></body></html>