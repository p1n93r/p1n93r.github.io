<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>集合 - P1n93r - 博学而精一</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Pinger" /><meta name="description" content="概述 集合类也被称为 容器 ，所有的集合都位于java.util包下。 集合类家族主要由Collection和Map接口派生出。 集合相比数组的优势是" /><meta name="keywords" content="Security, Java, Web, Android" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="https://p1n93r.github.io/post/java/%E9%9B%86%E5%90%88/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="集合" />
<meta property="og:description" content="概述 集合类也被称为 容器 ，所有的集合都位于java.util包下。 集合类家族主要由Collection和Map接口派生出。 集合相比数组的优势是" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://p1n93r.github.io/post/java/%E9%9B%86%E5%90%88/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-10-18T19:50:36+08:00" />
<meta property="article:modified_time" content="2019-10-18T19:50:36+08:00" />

<meta itemprop="name" content="集合">
<meta itemprop="description" content="概述 集合类也被称为 容器 ，所有的集合都位于java.util包下。 集合类家族主要由Collection和Map接口派生出。 集合相比数组的优势是"><meta itemprop="datePublished" content="2019-10-18T19:50:36+08:00" />
<meta itemprop="dateModified" content="2019-10-18T19:50:36+08:00" />
<meta itemprop="wordCount" content="7582">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="集合"/>
<meta name="twitter:description" content="概述 集合类也被称为 容器 ，所有的集合都位于java.util包下。 集合类家族主要由Collection和Map接口派生出。 集合相比数组的优势是"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">P1n93r</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">P1n93r</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">集合</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-10-18 </span>
        <div class="post-category">
            <a href="/categories/java/"> Java </a>
            </div>
          <span class="more-meta"> 约 7582 字 </span>
          <span class="more-meta"> 预计阅读 16 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#概述">概述</a></li>
        <li><a href="#collection和iterator">Collection和Iterator</a></li>
        <li><a href="#set集合">Set集合</a>
          <ul>
            <li><a href="#hashset">HashSet</a></li>
            <li><a href="#lindedhashset">LindedHashSet</a></li>
            <li><a href="#treeset">TreeSet</a></li>
            <li><a href="#各个set实现类比较">各个Set实现类比较</a></li>
          </ul>
        </li>
        <li><a href="#list集合">List集合</a>
          <ul>
            <li><a href="#listiterator">ListIterator</a></li>
            <li><a href="#arraylist">ArrayList</a></li>
          </ul>
        </li>
        <li><a href="#queue集合">Queue集合</a></li>
        <li><a href="#map集合">Map集合</a>
          <ul>
            <li><a href="#hashmap">HashMap</a></li>
            <li><a href="#linkedhashmap">LinkedHashMap</a></li>
            <li><a href="#properties类读写属性文件">Properties类读写属性文件</a></li>
            <li><a href="#sortedmap接口和treemap实现类">SortedMap接口和TreeMap实现类</a></li>
            <li><a href="#identityhashmap">IdentityHashMap</a></li>
          </ul>
        </li>
        <li><a href="#各个map实现类比较">各个Map实现类比较</a></li>
        <li><a href="#collections工具类">Collections工具类</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="概述">概述</h2>
<ul>
<li>集合类也被称为 <strong>容器</strong> ，所有的集合都位于java.util包下。</li>
<li>集合类家族主要由Collection和Map接口派生出。</li>
<li>集合相比数组的优势是：长度可变，且能存储不同类型的对象。Map还能存储映射关系。</li>
<li><strong>集合只能存储对象，不能存储基本类型的值。</strong></li>
<li>Set代表无序不可重复，List代表有序可重复，Map代表无序不可重复键值的映射，Queue代表队列集合。</li>
</ul>
<p>Collection的家谱如下图：</p>
<p><img src="/media/20191018-1.png" alt="Collection家谱"></p>
<p>Map的家谱如下图：</p>
<p><img src="/media/20191018-2.png" alt="Map家谱"></p>
<h2 id="collection和iterator">Collection和Iterator</h2>
<p>Collection是Set、List和Queue父接口，此接口定义了一些操作结合元素的基本方法。可以查看Java8的api文档。此外，Collection定义了一个返回迭代器的方法iterator(),返回一个Iterator类型的迭代器，Iterator必须依赖于Collection对象，迭代器主要如下有三个方法：</p>
<ol>
<li>boolean hasNext():如果被迭代的集合元素还没有被遍历，则返回true。</li>
<li>Object next():返回集合里的下一个迭代对象。</li>
<li>void remove():删除集合里上一次next方法返回的元素。</li>
</ol>
<p>一个Iterator的使用例子如下（也包括了foreach的使用）：</p>
<pre><code>@Test
public void test_1(){
    List&lt;String&gt; a=new ArrayList&lt;&gt;();
    for(int i=0;i&lt;5;i++){
        a.add(&quot;我是&quot;+i);
    }
    Iterator&lt;String&gt; iterator=a.iterator();
    while(iterator.hasNext()){
        String temp=iterator.next();
        if(temp.equals(&quot;我是2&quot;)){
            iterator.remove();
        }
        System.out.println(temp);
    }
    System.out.println(&quot;------------分割线---------------&quot;);
    for(String v:a){
        System.out.println(v);
    }
}
</code></pre>
<p>输出结果如下图：</p>
<p><img src="/media/20191018-3.png" alt="结果1"></p>
<p><em><strong>Notice:</strong></em> Iterator方式和foreach方式迭代过程中，不能直接对集合进行改变，否则会报错： <code>java.util.ConcurrentModificationException</code> ,所有的内部基于数组来实现的集合，最好用随机访问，其他的采用迭代访问。</p>
<h2 id="set集合">Set集合</h2>
<p>Set判断两个对象相等的原则是：两个对象用equals方法返回true。在此基础上再来了解HashSet、SortedSet、LinkedHashSet。</p>
<h3 id="hashset">HashSet</h3>
<ul>
<li>HashSet判断两个对象是否相等的条件是： <strong>两个对象通过equals()方法返回true且两者的hashCode()方法返回值相等。</strong> 此外，如果两个对象的equals()返回false，但hashCode()返回的值相同，HashSet会将两个对象存储在相同的位置，使用链表结构保存，会导致性能下降。</li>
<li>HashSet按照Hash算法来存储集合中的元素，具有 <strong>很好的存取和查找性能。</strong></li>
<li>多个线程同时访问HashSet需要通过代码保证其同步。</li>
<li><strong>集合元素可以为null</strong></li>
<li>需要被保存到HashSet中的对象，需要重写其equals()和hashCode()方法，保证两者通过equals()方法返回为true时，两者的hashCode()方法返回也相同。</li>
<li>当HashSet中存储了对象时，此时再修改它，可能会导致它与其他对象相等（值相等），此时会导致HashSet无法准确的访问元素。</li>
</ul>
<p>一个例子如下：</p>
<pre><code>package com.test.commonClass;
import java.util.HashSet;
import java.util.Set;

public class R {
    private int count;
    public R(int count){
        this.count=count;
    }
    @Override
    public String toString(){
        return &quot;R[count:&quot;+count+&quot;]&quot;;
    }
    @Override
    public int hashCode(){
        return this.count;
    }
    @Override
    public boolean equals(Object obj){
        if(obj==this){
            return true;
        }else{
            if(obj!=null&amp;&amp;obj.getClass()==this.getClass()){
                R temp=(R)obj;
                return temp.getCount()==this.getCount()? true:false;
            }
        }
        return false;
    }
    public int getCount() {
        return count;
    }
    public void setCount(int count) {
        this.count = count;
    }
    public static void main(String[] args){
        Set&lt;R&gt; set=new HashSet&lt;&gt;();
        R a=new R(1);
        set.add(a);
        set.add(new R(2));
        set.add(new R(3));
        System.out.println(set);
        //现在改变count为1的那个元素
        a.setCount(3);
        System.out.println(set);
        //现在删除count为3的元素，将hash命中定位到第三个元素，所以删除第三个元素
        set.remove(new R(3));
        System.out.println(set);
        //此时虽然打印出的结果中，在第一个元素那有一个count为3的元素，但是我们去找到它已经找不到了
        System.out.println(&quot;是否还有count为3的元素&quot;+set.contains(new R(3)));
        System.out.println(&quot;是否还有count为1的元素&quot;+set.contains(new R(1)));
    }
}
</code></pre>
<p>输出结果如下图：</p>
<p><img src="/media/20191018-4.png" alt="结果2"></p>
<h3 id="lindedhashset">LindedHashSet</h3>
<ul>
<li>LindedHashSet是HashSet的子类，也是根据元素的hash值来决定元素的存储位置。</li>
<li>LindedHashSet以链表结构维护元素的次序，所以 <strong>元素是有序的</strong> ，顺序是其添加顺序。</li>
<li>LinkedHashSet性能略低于HashSet，<strong>但是迭代访问将会有很好的性能</strong>。</li>
</ul>
<h3 id="treeset">TreeSet</h3>
<ul>
<li><strong>TreeSet判断两个对象是否相等的依据是（自然排序时）：两者通过compareTo()方法返回0，但是为了照顾常规思维，也得保证此时两者通过equals()方法返回true且hashCode()方法返回值相等。</strong></li>
<li>TreeSet是SortedSet接口的实现类，其集合元素处于排序状态。</li>
<li>TreeSet还提供了返回第一个，最后一个，前一个，后一个元素方法；还有截取集合获得子集的方法。</li>
<li>TreeSet可以使用 <strong>定制排序和自然排序。</strong> 默认情况采用自然排序。</li>
<li>TreeSet采用 <strong>红黑树的数据结构来存储集合元素。</strong></li>
<li>添加到TreeSet中的元素必须是 <strong>同样的数据类型的对象。</strong></li>
</ul>
<h4 id="自然排序">自然排序</h4>
<p>自然排序要求元素的类实现了 <code>Comparable</code> 接口的 <code>compareTo(Object obj)</code> 方法。实现了该接口的类的对象就可以进行大小比较。例如 <code>obj.compareTo(obj1)</code> 的结果，如果返回0，则代表两者相等；如果返回正整数，则代表obj大于obj1；如果返回一个负整数，则代表obj小于obj1；常见的实现了Comparable接口的类如下：</p>
<ul>
<li>Character：按照字符的UNICODE值进行比较。</li>
<li>Boolean：true对应的包装类实例大于false对应的包装类实例。</li>
<li>String：按照字符串中字符的UNICODE值进行比较。</li>
<li>Date、Time：后面的日期和时间比前面的日期和时间要大。</li>
</ul>
<p>往TreeSet中加入元素要么需要定制排序，要么需要自然排序。而自然排序就是待加入元素的类需要实现 <code>Comparable</code> 接口的 <code>compareTo(Object obj)</code> 方法。如果使用自然排序，但是其元素没有实现Comparable接口，添加第一个元素时不会报错，但是第二个元素会报错（第二个元素需要与第一个元素进行比较，此时两者不能进行比较从而报错）。此外需要注意的地方如下：</p>
<ol>
<li>就算两个对象都实现了Comparable接口，但是不是同一个类型的对象，也不能被添加到TreeSet。</li>
<li>加入到TreeSet中的对象最好是不可变对象，防止其属性被修改而导致查找元素时的比较出问题（只能查找到没有改变且不与其他改变后导致与自己重复的元素）。</li>
</ol>
<h4 id="定制排序">定制排序</h4>
<p>实例化一个TreeSet的时候可以传入一个匿名对象，此匿名对象是Comparator接口的实例。一个例子如下：</p>
<pre><code>public class TreeSetTest {
    @Test
    public void test1(){
        TreeSet&lt;R&gt; rs = new TreeSet&lt;&gt;(new Comparator&lt;R&gt;() {
            @Override
            public int compare(R o1, R o2) {
                return o1.getCount() == o2.getCount() ? 0 : o1.getCount() &gt; o2.getCount() ? 1 : -2;
            }
        });
        rs.add(new R(-3));
        rs.add(new R(4));
        rs.add(new R(-2));
        rs.add(new R(1));
        rs.add(new R(3));
        //输出：[R[count:-3], R[count:-2], R[count:1], R[count:3], R[count:4]]
        System.out.println(rs);
    }
}
</code></pre>
<p><em><strong>Notice</strong></em>：此种方法同样不能在TreeSet中添加不同类型的元素。</p>
<h3 id="各个set实现类比较">各个Set实现类比较</h3>
<ol>
<li>HashSet的性能总是比TreeSet好，尤其是插入和查找操作。只有当需要一个保持排序的Set时，才使用TreeSet。</li>
<li>HashSet的子类LinkedHashSet，对于删除和插入操作，比HashSet慢一点（维护链表带来的额外开销造成的），不过因为是链表，所以遍历LinkedHashSet会更快。</li>
<li>总而言之：<strong>需要排序的Set，用TreeSet；一般使用HashSet；经常遍历的用LinkedHashSet。</strong></li>
</ol>
<h2 id="list集合">List集合</h2>
<p>List接口比Collection接口的迭代器多了反向迭代的功能。List集合代表有序可重复的集合，每个元素都有其对应的顺序索引。此外与Set集合相比，多了根据索引来插入，删除，替换的方法。List判断两个对象是否相等的前提是两者通过equals()方法返回true。一个例子如下：</p>
<pre><code>class R{
    @Override
    public boolean equals(Object obj){
        //无论与谁相比都是true
        return true;
    }
}
public class ListTest {
    @Test
    public void test1(){
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;落霞与孤鹜齐飞&quot;);
        list.add(&quot;秋水共长天一色&quot;);
        //因为R类的对象与谁通过equals()比较都是true，所以会输出true
        System.out.println(list.contains(new R()));
        //输出：[落霞与孤鹜齐飞, 秋水共长天一色]
        System.out.println(list);
        //当R对象与list的第一个元素通过equals()比较时，返回true，所以会在第一元素删除它
        list.remove(new R());
        //输出：[秋水共长天一色]
        System.out.println(list);
        //同上次的remove()一样，会在比较第一个元素时就把它删除了，所以下面将输出空的List集合
        list.remove(new R());
        //输出：[]
        System.out.println(list);
    }
}
</code></pre>
<h3 id="listiterator">ListIterator</h3>
<p>与Set不同的是，List提供一个可以反向迭代的ListIterator迭代器。该接口继承于Iterator接口，在其基础上增加了如下方法：</p>
<ol>
<li>boolean hasPrevious()：该迭代器关联的集合是否有上一个元素。</li>
<li>Object previous()：返回该迭代器的上一个元素。</li>
<li>void add()：在指定位置插入一个元素。</li>
</ol>
<p>一个使用例子如下：</p>
<pre><code>@Test
public void test2(){
    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add(&quot;落霞与孤鹜齐飞&quot;);
    list.add(&quot;秋水共长天一色&quot;);
    list.add(&quot;关山难越&quot;);
    list.add(&quot;谁背失路之人&quot;);
    list.add(&quot;哀吾生之须臾&quot;);
    list.add(&quot;羡长江之无穷&quot;);
    ListIterator&lt;String&gt; iterator=list.listIterator();
    while(iterator.hasNext()){
        System.out.println(iterator.next());
    }
    //接下来反向迭代（先正向迭代，指针到了后面才能反向迭代）
    while(iterator.hasPrevious()){
        System.out.println(iterator.previous());
    }
}
</code></pre>
<p>输出截图如下：</p>
<p><img src="/media/20191022-1.png" alt="结果3"></p>
<h3 id="arraylist">ArrayList</h3>
<p>ArrayList是一个基于数组的实现的List类，所以随机访问性能比较好。虽然ArrayList相对数组而言，可以动态的改变元素的个数，但是其实实例化时，也可以指定ArrayList的个数（不指定默认为10）。后面如果超出了这个数量，则会动态分配大小，但是如果提前就知道了需要存储比较多的元素时，可以直接调用ArrayList的 <code>ensureCapacity()</code> 方法来一次性地增加initialCapacity，可以减少重新分配的次数，从而提高性能。此外，可以调用 <code>trimToSize()</code> 方法来调整其内部的数组长度为当前元素个数，从而减少了ArrayList占用的空间。一个实例代码如下：</p>
<pre><code>@Test
public void test3(){
    //实例化时指定List集合的initialCapacity，长度超出时会自动增长。
    //如果不写，默认为10
    ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(10);
    ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();
    //当一开始不知道需要多大的List空间时，可以之后利用其ensureCapacity()方法来指定其元素个数
    //这样避免总是自动分配，提高性能
    list2.ensureCapacity(100);
    for(int i=0;i&lt;40;i++){
        list2.add(String.valueOf(i));
    }
    list2.trimToSize();
}
</code></pre>
<p>此外还有一个不可变长度的ArrayList，就是Arrays.ArrayList类（这个ArrayList是Arrays的内部类），可以通过调用Arrays的asList()方法来将一个数组转换成其内部类ArraysList的对象。此对象不可添加和删除元素。实例代码如下：</p>
<pre><code>@Test
public void test4(){
    String[] a=new String[]{&quot;one&quot;,&quot;two&quot;,&quot;three&quot;};
    List&lt;String&gt; list = Arrays.asList(a);
    //下面的操作会报错
    System.out.println(list.add(&quot;four&quot;)+&quot;,&quot;+list.remove(&quot;one&quot;));
}
</code></pre>
<h2 id="queue集合">Queue集合</h2>
<p>Queue主要是为了模拟队列这种数据结构。常用到的有Deque接口的实现类ArrayDeque和LinkedDeque。Deque代表双端队列，如果需要使用到栈这种数据结构，推荐使用ArrayDeque和LinkedDeque。前者随机访问性能比较好，后者迭代访问性能比较好。两者主要方法可以查看api文档。</p>
<h2 id="map集合">Map集合</h2>
<p>Map就是存储具有映射关系的数据，就是所谓的键值对。Map的key不允许重复，但是允许为null（也只能存在一个）。Map判断键值对的key相等的规则也是两者通过equals()方法返回true则认为它们相等。其实Java是先实现了Map再实现了Set，Set就是键值对中值为null的Map。Map接口常用方法如下：</p>
<ul>
<li>Set entrySet()：返回Map中包含的键值对所组成的Set集合，每个集合元素都是Map.Entry对象。</li>
<li>boolean isEmpty()：判断此Map是否为空。</li>
<li>Set keySet()：返回该Map中所有key组成的Set集合。</li>
<li>Collection values()：返回该Map中所有键值对的值组成的Collection。</li>
</ul>
<p>其中Map.Entry的主要几个方法如下：</p>
<ul>
<li>Object getKey()：返回该键值对的键。</li>
<li>Object getValue()：返回该键值对的值。</li>
<li>Object setValue()：设置该键值对的值，并返回新设置的值。</li>
</ul>
<h3 id="hashmap">HashMap</h3>
<ul>
<li>Map接口常用的实现类就是HashMap了，但 <strong>它不是一个线程安全的类，</strong> 可以使用Collections工具类将HashMap变成线程安全来使用。</li>
<li>HashMap允许最多存在一个键为null的键值对（也允许将键值对的值设置为null，这个允许多个）</li>
<li>存放在HashMap中的键值对的键必须实现equals()和hashCode()方法，保证两者通过equals()方法返回true时，两者的hashCode()返回的值相等。</li>
<li>HashMap键值对的值相等的原则是两者通过equals()方法返回true。</li>
<li>尽量不要使用可变对象作为HashMap的键。</li>
</ul>
<p>一个HashMap有关的综合例子如下：</p>
<pre><code>@Test
public void test5(){
    Map&lt;String,Integer&gt; map=new HashMap&lt;&gt;();
    System.out.println(map.put(&quot;嘻嘻&quot;,0));
    System.out.println(map.put(new String(&quot;哈哈&quot;),1));
    //已存在“哈哈”键的映射，此时将会替换旧值，并返回旧值（没有发生替换是返回的是null）
    System.out.println(map.put(new String(&quot;哈哈&quot;),2));
    //存放键为null的映射
    System.out.println(map.put(null,3));
    //存放值为null的映射
    System.out.println(map.put(&quot;哇呜&quot;,null));
    //再次放入一个已存在键的映射，任然会替换这个键的值，返回被替换的旧值
    System.out.println(map.put(null,4));
    System.out.println(&quot;Map大小：&quot;+map.size());
    System.out.println(&quot;Map元素：&quot;+map);

    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();
    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entries.iterator();
    System.out.println(&quot;-----------------遍历HashMap方式一：通过Entry（速度最快）------------------&quot;);
    while(iterator.hasNext()){
        Map.Entry tmp=iterator.next();
        System.out.println(tmp.getKey()+&quot;::::&quot;+tmp.getValue());
    }
    System.out.println(&quot;---------------遍历HashMap方式二：利用keySet（折中了下，速度慢）------------------&quot;);
    Iterator&lt;String&gt; iterator1 = map.keySet().iterator();
    while (iterator1.hasNext()){
        String key=iterator1.next();
        System.out.println(key+&quot;::::&quot;+map.get(key));
    }
    //以上两种遍历方式都可以将迭代器方式换成foreach方式。（foreach其实也是调用的iterator）
    //换成foreach其实和用迭代器速度差不多，但foreach更加简洁易懂
    //需要注意的是，只有基于链表实现的容器，遍历才需要避免使用get方式（可用foreach和iterator方式）
}
</code></pre>
<p>运行结果如下：</p>
<p><img src="/media/20191025-1.png" alt="HashMap结果"></p>
<h3 id="linkedhashmap">LinkedHashMap</h3>
<p>LinkedHashMap是HashMap的子类，此类需要维护元素插入的顺序，以链表来维护内部的顺序，迭代访问时具有不错的性能。一个案例如下：</p>
<pre><code>@Test
public void test6(){
    LinkedHashMap&lt;String, Integer&gt; map = new LinkedHashMap&lt;&gt;();
    map.put(&quot;一&quot;,1);
    map.put(&quot;二&quot;,2);
    map.put(&quot;三&quot;,3);
    map.put(&quot;四&quot;,4);
    map.put(&quot;五&quot;,5);
    for (Map.Entry&lt;String,Integer&gt; v:map.entrySet()){
        //对于内部用链表维护的容器，避免使用get方式遍历
        System.out.println(v.getKey()+&quot;::::&quot;+v.getValue());
    }
}
</code></pre>
<p>运行结果如下：</p>
<p><img src="/media/20191025-2.png" alt="LinkedHashMap结果"></p>
<h3 id="properties类读写属性文件">Properties类读写属性文件</h3>
<p>Hashtable是一个和HashMap很类似类，Hashtable不允许存在键或值为null的映射，其他的和HashMap差不多（但是过于古老，不建议使用）。而Properties则是Hashtable的一个子类。Properties可以将Map对象和属性文件关联起来，可以把Map的键值对写入属性文件中，也可以把属性文件中的 <code>属性=属性值</code> 加载到Map中，同时由于属性文件中的“属性”和“属性值”都是字符串类型的，所以Properties中的键值对都是String类型的。此类提供常用的三个方法：</p>
<ol>
<li>String getProperty(String key)：获取指定键的属性值。</li>
<li>String getPropery(String key,String defaultValue)：获取指定键的属性值，如果不存在，则添加此键的默认值。</li>
<li>Object setProperty(String key,String value)：设置属性值。</li>
<li>void load(InputStream inStream)：从属性文件加载键值对，追加到当前Properties对象。</li>
<li>void store(OutputStream outStream,String comments)：将Properties对象中的键值对输出到指定的属性文件中。comments表示注释。</li>
</ol>
<p>一个测试代码如下：</p>
<pre><code>@Test
public void test7() throws IOException {
    Properties properties = new Properties();
    properties.setProperty(&quot;username&quot;,&quot;root&quot;);
    properties.setProperty(&quot;password&quot;,&quot;123456&quot;);
    FileOutputStream out = new FileOutputStream(&quot;res/properties/test.properties&quot;);
    properties.store(out,&quot;just a test~~&quot;);
    //再创建另一个Properties对象，加载刚在创建的属性文件
    Properties properties1 = new Properties();
    properties1.setProperty(&quot;driver&quot;,&quot;mysql8&quot;);
    properties1.load(new FileInputStream(&quot;res/properties/test.properties&quot;));
    //将输出：{password=123456, driver=mysql8, username=root}，可将load是追加方式，而不是覆盖方式
    System.out.println(properties1);
    //再将第二个properties对象写入到xml文件中
    properties1.storeToXML(new FileOutputStream(&quot;res/xml/test.xml&quot;),&quot;只是测试&quot;,&quot;UTF-8&quot;);
}
</code></pre>
<p>res/properties/test.properties内容如下图：</p>
<p><img src="/media/20191025-3.png" alt="属性文件"></p>
<p>res/xml/test.xml内容如下图：</p>
<p><img src="/media/20191025-4.png" alt="xml文件"></p>
<h3 id="sortedmap接口和treemap实现类">SortedMap接口和TreeMap实现类</h3>
<p>Map接口派生出一个SortedMap接口，此接口有一个实现类TreeMap。每个键值对作为一个红黑树的节点，TreeMap里存放的键值对的键的要求和TreeSet一样。具体的往前TreeSet看便知。</p>
<h3 id="identityhashmap">IdentityHashMap</h3>
<p>这个Map实现类的实现机制与HashMap基本相似，但是这个Map比较两个键相等的规则是严格相等（两者通过 <code>==</code> 运算符得到true时）。</p>
<p>一个例子如下：</p>
<pre><code>@Test
public void test8(){
    IdentityHashMap&lt;String, Integer&gt; map = new IdentityHashMap&lt;&gt;();
    map.put(new String(&quot;pinger&quot;),18);
    //由于IdentityHashMap判断两个key相等的原则时两者严格相等，所以下面的input能够被添加成功。
    map.put(new String(&quot;pinger&quot;),20);
    //输出：{pinger=20, pinger=18}
    System.out.println(map);
}
</code></pre>
<h2 id="各个map实现类比较">各个Map实现类比较</h2>
<ol>
<li>HashMap和Hashtable效率差不多，前者线程不安全，后者线程安全。</li>
<li>TreeMap比HashMap和Hashtable慢，但是其键时有序的（可以利用二分法查找需要的键）。</li>
<li>LinkedHashMap比HashMap慢一点，通过链表维护添加元素的顺序。</li>
<li>IdentityHashMap除了“键严格相等”外无其他特点。</li>
</ol>
<h2 id="collections工具类">Collections工具类</h2>
<p>Collections工具类提供了大量对集合元素进行操作的方法。这些操作去查看java的API文档。此外Collections工具类有两个需要注意的功能：</p>
<ol>
<li>同步控制</li>
<li>设置不可变集合</li>
</ol>
<p>创建线程同步的集合的实例如下：</p>
<pre><code>@Test
public void test9(){
    Set&lt;Object&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());
    List&lt;Object&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());
    Map&lt;Object, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());
    Collection&lt;Object&gt; collection = Collections.synchronizedCollection(new TreeSet&lt;&gt;());
}
</code></pre>
<p>设置不可变集合的实例如下：</p>
<pre><code>@Test
public void test10(){
    //创建一个空的、不可改变的List集合
    List&lt;Object&gt; list = Collections.emptyList();
    //创建只有一个元素的、不可改变的Set集合
    Set&lt;Integer&gt; singleton = Collections.singleton(1);
    Map map=new HashMap();
    map.put(&quot;一&quot;,1);
    map.put(&quot;二&quot;,2);
    //返回上面创建的map的不可变版本
    Map map1 = Collections.unmodifiableMap(map);
}
</code></pre>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Pinger</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-10-18
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/mybatis/mybatis%E6%87%92%E5%8A%A0%E8%BD%BD/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Mybatis懒加载</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/other/%E9%AB%98%E6%95%88%E5%88%9B%E5%BB%BAip%E4%BB%A3%E7%90%86%E6%B1%A0/">
            <span class="next-text nav-default">高效创建ip代理池</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'p1n93r';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:pin83r@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/p1n93r" class="iconfont icon-github" title="github"></a>
  <a href="https://p1n93r.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2019 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>P1n93r</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>








</body>
</html>
