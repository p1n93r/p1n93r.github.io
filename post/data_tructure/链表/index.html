<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>链表 - P1n93r - 博学而精一</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="P1n93r"><meta name=description content="什么是链表 链表是一种用于存储数据集合的数据结构。链表有以下属性： 相邻元素之间通过指针连接。 最后一个元素的后继指针值为null。 在程序执行过程"><meta name=keywords content="Security,Java,Web,Android"><meta name=generator content="Hugo 0.99.1 with theme even"><link rel=canonical href=https://p1n93r.github.io/post/data_tructure/%E9%93%BE%E8%A1%A8/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="链表"><meta property="og:description" content="什么是链表 链表是一种用于存储数据集合的数据结构。链表有以下属性： 相邻元素之间通过指针连接。 最后一个元素的后继指针值为null。 在程序执行过程"><meta property="og:type" content="article"><meta property="og:url" content="https://p1n93r.github.io/post/data_tructure/%E9%93%BE%E8%A1%A8/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-03-02T22:29:36+08:00"><meta property="article:modified_time" content="2020-03-02T22:29:36+08:00"><meta itemprop=name content="链表"><meta itemprop=description content="什么是链表 链表是一种用于存储数据集合的数据结构。链表有以下属性： 相邻元素之间通过指针连接。 最后一个元素的后继指针值为null。 在程序执行过程"><meta itemprop=datePublished content="2020-03-02T22:29:36+08:00"><meta itemprop=dateModified content="2020-03-02T22:29:36+08:00"><meta itemprop=wordCount content="2919"><meta itemprop=keywords content="数据结构与算法,"><meta name=twitter:card content="summary"><meta name=twitter:title content="链表"><meta name=twitter:description content="什么是链表 链表是一种用于存储数据集合的数据结构。链表有以下属性： 相邻元素之间通过指针连接。 最后一个元素的后继指针值为null。 在程序执行过程"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>P1n93r</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>P1n93r</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>链表</h1><div class=post-meta><span class=post-time>2020-03-02</span><div class=post-category><a href=/categories/data_structure/>data_structure</a></div><span class=more-meta>约 2919 字</span>
<span class=more-meta>预计阅读 6 分钟</span>
<span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次阅读</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#什么是链表>什么是链表</a></li><li><a href=#链表与数组比较>链表与数组比较</a><ul><li><a href=#链表优缺点>链表优缺点</a></li><li><a href=#数组优缺点>数组优缺点</a></li></ul></li><li><a href=#单向链表>单向链表</a><ul><li><a href=#链表的基本操作>链表的基本操作</a></li></ul></li><li><a href=#双向链表>双向链表</a><ul><li><a href=#双向链表优缺点>双向链表优缺点</a></li><li><a href=#双向链表的插入操作>双向链表的插入操作</a></li><li><a href=#双向链表的删除操作>双向链表的删除操作</a></li></ul></li><li><a href=#循环链表>循环链表</a><ul><li><a href=#统计循环链表的节点的个数>统计循环链表的节点的个数</a></li><li><a href=#输出循环链表的内容>输出循环链表的内容</a></li><li><a href=#循环链表的插入操作>循环链表的插入操作</a></li><li><a href=#循环链表的删除操作>循环链表的删除操作</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=什么是链表>什么是链表</h2><p>链表是一种用于存储数据集合的数据结构。链表有以下属性：</p><ol><li>相邻元素之间通过指针连接。</li><li>最后一个元素的后继指针值为null。</li><li>在程序执行过程中，链表的长度可以增加或缩小。</li><li>链表的空间能够按需分配。</li><li>链表不存在内存空间的浪费（但是链表中的指针需要一些额外的内存开销）。</li></ol><p>链表的图示如下：</p><p><img src=/media/20200304-1.png alt=带头结点的单链表></p><h2 id=链表与数组比较>链表与数组比较</h2><h3 id=链表优缺点>链表优缺点</h3><p>优点：</p><ol><li>链表不存在内存空间的浪费。</li><li>链表在执行插入和删除操作有优异的性能。</li><li>链表的空间能够按需分配。</li></ol><p>缺点：</p><ol><li>不适合随机存取的场景。</li><li>链表操作需要额外的辅助指针，需要浪费一定空间。</li></ol><h3 id=数组优缺点>数组优缺点</h3><p>优点：</p><ol><li>简单易用。</li><li>访问元素快（随机访问）。</li></ol><p>缺点：</p><ol><li>大小固定。</li><li>分配一个连续的存储空间。</li><li>基于位置的插入操作实现复杂。</li></ol><h2 id=单向链表>单向链表</h2><p><strong>链表通常指的是单向链表</strong> ，单向链表包含多个节点，每个节点有一个指向其后继节点的next指针。链表中的最后一个节点的next指针为null，表示链表的结束。单链表图示如下：</p><p><img src=/media/20200304-1.png alt=单链表></p><h3 id=链表的基本操作>链表的基本操作</h3><ol><li>遍历链表。</li><li>在链表中插入一个元素。</li><li>从链表中删除一个元素。</li></ol><h4 id=链表的遍历>链表的遍历</h4><p>遍历一个链表需要以下步骤：</p><ol><li>沿指针遍历。</li><li>遍历时显示节点的内容（或计数）。</li><li>当next指针的值为null的时候结束遍历。</li></ol><p>一个遍历链表的函数例子如下：</p><pre><code>//遍历带头结点的链表
int getLinkedListLength(Node headNode){
	int length=0;
	Node current=headNode.next;
	while(current!=null){
		length++;
		current=current.getNext();
	}
}
</code></pre><p>时间复杂度为O(n)，用于扫描长度为n的链表。空间复杂度为O(1)，仅用于创建临时变量。</p><h4 id=单向链表的插入>单向链表的插入</h4><p>单向链表的插入操作分为3种情况：</p><ol><li>在链表的表头插入一个新的节点（链表开始处）。</li><li>在链表的表尾插入一个新的节点（链表的结尾处）。</li><li>在链表的中间插入一个新的节点（随机位置）。</li></ol><h5 id=链表开始处>链表开始处</h5><p>操作如下：</p><p><img src=/media/20200304-2.png alt=链表开始处插入节点></p><h5 id=链表的结尾处>链表的结尾处</h5><p>操作如下：</p><p><img src=/media/20200304-3.png alt=链表结尾处插入节点></p><p><em><strong>Notice</strong></em> :不要忘记使新插入节点的next指向null。</p><h5 id=随机位置>随机位置</h5><p>操作如下：</p><p><img src=/media/20200304-4.png alt=随机位置插入新节点></p><p>一个实现案例如下(综合插入操作)：</p><pre><code>//将新节点插入到pos前，且pos是从1开始计算
ListNode insertInLinkedList(ListNode headNode,ListNode nodeToInsert,int pos){
	if(headNode==null){//如果链表为空
		return nodeToInsert;
	}
	int size=getLinkedListLength(headNode);
	if(pos&gt;size+1||pos&lt;1){//如果插入的位置不对
		System.out.println(&quot;输入错误，请检查你的插入位置！&quot;);
		return headNode;
	}
	if(pos==1){//如果将节点插入到链表的头
		nodeToInsert.setNext(headNode);
		return nodeToInsert;
	}else{//在链表的中间或者末尾插入
		ListNode preNode=headNode;
		int count=1;
		//先找到需要插入的位置
		while(count&lt;pos-1){
			preNode=preNode.getNext();
			count++;
		}
		//开始插入
		ListNode temp=preNode.getNext();
		nodeToInsert.setNext(temp);
		preNode.setNext(nodeToInsert);
	}
	return headNode;
}
</code></pre><p>时间复杂度为O(n)。因为最差的情况下，可能需要在链尾插入节点。空间复杂度为O(1)，仅用于创建一个临时变量。</p><h4 id=单向链表的删除>单向链表的删除</h4><p>与单向链表的插入相似，删除也分为3种情况：</p><ol><li>删除链表的表头（第一个）节点。</li><li>删除链表的表尾（最后一个）节点。</li><li>删除链表中间的节点。</li></ol><h5 id=删除单向链表的第一个节点>删除单向链表的第一个节点</h5><p>操作如下：</p><p><img src=/media/20200304-5.png alt=删除单向链表的第一个节点></p><h5 id=删除单向链表的最后一个节点>删除单向链表的最后一个节点</h5><p>操作如下：</p><p><img src=/media/20200304-6.png alt=删除单向链表的最后一个节点></p><h5 id=删除单向链表中间的一个节点>删除单向链表中间的一个节点</h5><p>操作如下：</p><p><img src=/media/20200304-7.png alt=删除单向链表的中间的一个节点></p><p>一个代码实现例子如下（综合删除操作）：</p><pre><code>//删除pos位置的节点
ListNode deleteNodeFromLinkedList(ListNode headNode,int pos){
	int size=getLinkedListLength(headNode);
	if(pos&gt;size||pos&lt;1){
		System.out.println(&quot;输出非法，请检查pos的输入！&quot;);
		return headNode;
	}
	if(pos==1){//如果删除第一个节点
		headNode=headNode.getNext();
		return headNode;
	}else{//删除中间的节点或者链尾的节点
		ListNode temp=headNode;
		int index=1;//例子中的索引从1开始
		while(index&lt;pos-1){//找到pos位置的前驱节点
			temp=temp.getNext();
			index++;
		}
		ListNode deleted=temp.getNext();
		temp.setNext(deleted.getNext());
		deleted.setNext(null);
		deleted=null;//通知JVM回收垃圾
	}
	return headNode;
}
</code></pre><p>时间复杂度为O(n)，因为最差的情况下，可能需要删除链尾节点。空间复杂度为O(1),因为仅创建了一个临时变量。</p><h5 id=删除单向链表>删除单向链表</h5><p>删除单向链表，需要将当前节点存储在一个临时变量里，然后释放当前节点（使当前节点的变量等于null，Java垃圾回收机制会自动回收空间）。当释放当前节点，移动到下一个节点并将其存储到临时变量，然后不断重复该过程直到释放所有节点。一个代码示例如下：</p><pre><code>void deleteLinkedList(ListNode headNode){
	ListNode current=headNode,next;
	while(current!=null){
		next=current.getNext();
		current.setNext(null);
		current=next;
	}
}
</code></pre><h2 id=双向链表>双向链表</h2><h3 id=双向链表优缺点>双向链表优缺点</h3><p>优点：</p><ol><li>对于链表中给定的一个节点，可以从两个方向进行操作。</li><li>删除一个节点时候，无需此节点的前驱节点也能删除该节点。</li></ol><p>缺点：</p><ol><li>每个节点需要添加一个额外的指针，因此需要更多的空间开销。</li><li>每个节点的插入和删除更加费时（需要更多的指针操作）。</li></ol><h3 id=双向链表的插入操作>双向链表的插入操作</h3><p>双向链表的插入与单链表一样，分为三种情况：</p><ol><li>在链表的开头插入一个新节点。</li><li>在链表的末尾插入一个新的节点。（插入链表的最后）</li><li>在链表的中间插入一个新的节点。</li></ol><h4 id=在双向链表的开始插入一个节点>在双向链表的开始插入一个节点</h4><p>操作如下：</p><p><img src=/media/20200304-8.png alt=在双向链表的开头插入节点></p><h4 id=在双向链表的末尾插入一个节点>在双向链表的末尾插入一个节点</h4><p>操作如下：</p><p><img src=/media/20200304-9.png alt=在双向链表的末尾插入一个节点></p><h4 id=在双向链表的中间插入一个节点>在双向链表的中间插入一个节点</h4><p>操作如下：</p><p><img src=/media/20200304-10.png alt=在双向链表的中间插入一个节点></p><p>一个代码实现案例如下：</p><pre><code>//将新节点插入到pos位置之前
ListNode insertInLinkedList(ListNode headNode,ListNode nodeToInsert,int pos){
	if(headNode==null){
		return nodeToInsert;
	}
	int size=getLinkedListLength(headNode);
	if(pos&gt;size+1||pos&lt;1){
		System.out.println(&quot;输入错误，请检查！&quot;);
		return nodeToInsert;
	}
	if(pos==1){
		nodeToInsert.setNext(headNode);
		headNode.setPre(nodeToInsert);
		return nodeToInsert;
	}else{
		ListNode current=headNode;
		int count=1;
		while(count&lt;pos-1){
			current=current.getNext();
			count++;
		}
		ListNode next=current.getNext();
		if(next!=null) next.setPre(nodeToInsert);
		nodeToInsert.setNext(next);
		nodeToInsert.setPre(current);
		current.setNext(nodeToInsert);
	}
	return headNode;
}
</code></pre><p>时间复杂度为O(n)，因为在最差的情况下，需要在链表的尾部进行插入节点。空间复杂度为O(1)，用于创建一个临时变量。</p><h3 id=双向链表的删除操作>双向链表的删除操作</h3><p>与单向链表的删除相似，也有3种情况：</p><ol><li>删除链表的表头节点。</li><li>删除链表的表尾（最后一个）节点。</li><li>删除链表中间的一个节点。</li></ol><h4 id=删除双向链表的第一个节点>删除双向链表的第一个节点</h4><p>操作如下：</p><p><img src=/media/20200304-11.png alt=删除双向链表的第一个节点></p><h4 id=删除双向链表的最后一个节点>删除双向链表的最后一个节点</h4><p>操作如下：</p><p><img src=/media/20200304-12.png alt=删除双向链表的最后一个节点></p><h4 id=删除双向链表中间的一个节点>删除双向链表中间的一个节点</h4><p>操作如下：</p><p><img src=/media/20200304-13.png alt=删除双向链表中间的一个节点></p><p>一个代码示例如下：</p><pre><code>//删除pos位置的节点，pos从1开始
ListNode delete(ListNode headNode,int pos){
	int size=getLinkedListLength(headNode);
	if(pos&gt;size+1||pos&lt;1){
		System.out.println(&quot;输入错误，请检查！&quot;);
	}
	if(pos==1){
		ListNode next=headNode.getNext();
		headNode.setNext(null);
		next.setPre(null);
		headNode=next;
		return headNode;
	}else{
		ListNode current=headNode;
		int count=1;
		while(count&lt;pos){
			current=current.getNext();
			count++;
		}
		ListNode next=current.getNext();
		if(next!=null) next.setPre(current.getPre());
		current.setNext(null);
		current.getPre().setNext(next);
		current.setPre(null);
		current=null;//没有引用指向这个对象，JVM会自动回收此垃圾
	}
	return headNode;
}
</code></pre><p>时间复杂度为O(n)，因为最差的情况下，可能需要删除链表的表尾节点。空间复杂度为O(1)，仅用于创建一个临时变量。</p><h2 id=循环链表>循环链表</h2><p>循环链表没有结束标志，单项链表和双向链表都采用了一个next指针指向为null来表示链表的结束，但是循环链表没有next指针为null的节点。</p><h3 id=统计循环链表的节点的个数>统计循环链表的节点的个数</h3><p>操作如下：</p><p><img src=/media/20200304-14.png alt=统计循环链表的节点的个数></p><p>一个代码示例如下：</p><pre><code>int getCircularLinkedListLength(CircularLinkedList headNode){
	int length=0;
	CircularLinkedList current=headNode;
	int length=0;
	while(current!=null){
		length++;
		current=current.getNext();
		if(current==headNode) break;
	}
	return length;
}
</code></pre><p>时间复杂度为O(n)，用于扫描长度为n的链表。空间复杂度为O(1)，仅用于创建一个临时变量。</p><h3 id=输出循环链表的内容>输出循环链表的内容</h3><p>和遍历操作差不多，一个代码示例如下：</p><pre><code>void printCircularLinkedListData(CircularLinkedList headNode){
	CircularLinkedList current=headNode;
	while(current!=null){
		System.out.println(&quot;数据为：&quot;+current.getData());
		current=current.getNext();
		if(current==head) break;
	}
}
</code></pre><p>时间复杂度为O(n)，用于扫描大小为n的链表。空间复杂度为O(1)，仅用于创建一个临时变量。</p><h3 id=循环链表的插入操作>循环链表的插入操作</h3><p>循环链表的在中间位置插入节点和单向链表一致，此处只讨论在表头和表尾插入节点的情况。</p><h4 id=在循环链表的表尾插入节点>在循环链表的表尾插入节点</h4><p>操作如下：</p><p><img src=/media/20200304-16.png alt=在循环链表的表尾插入节点></p><p>一个示例代码如下：</p><pre><code>void insertAtEndInCircularLinkedList(CircularLinkedList headNode,CircularLinkedList nodeToInsert){
	nodeToInsert.setNext(nodeToInsert);
	if(heaNode==null){
		headNode=nodeToInsert;
		return headNode;
	}else{
		//变量到最后一个节点
		CircularLinkedList current=headNode;
		while(true){
			current=current.getNext();
			if(current==headNode) break;
		}
		nodeToInsert.setNext(headNode);
		current.setNext(nodeToInsert);
	}
}
</code></pre><h4 id=在循环链表的表头插入节点>在循环链表的表头插入节点</h4><p>操作如下：</p><p><img src=/media/20200304-15.png alt=在循环链表的表头插入节点></p><p>一个示例代码如下：</p><pre><code>void insertBeginInCircularLinkedList(CircularLinkedList headNode,CircularLinkedList nodeToInsert){
	nodeToInsert.setNext(nodeToInsert);
	if(headNode==null){
		headNode=nodeToInsert;
		return headNode;
	}else{
		CircularLinkedList current=headNode;
		while(true){
			current=current.getNext();
			if(current==head) break;
		}
		nodeToInsert.setNext(headNode);
		current.setNext(nodeToInsert);
		headNode=nodeToInsert;
	}
	return headNode;
}
</code></pre><h3 id=循环链表的删除操作>循环链表的删除操作</h3><p>只讨论循环链表的删除表头和表尾的情况。</p><h4 id=删除循环链表中的最后一个节点>删除循环链表中的最后一个节点</h4><p>操作如下：</p><p><img src=/media/20200304-17.png alt=删除循环链表中的最后一个节点></p><p>一个代码示例如下：</p><pre><code>void deleteLastNodeFromCircularLinkedList(CircularLinkedList headNode){
	//先找到倒数第二个节点
	CircularLinkedList current=head;
	CircularLinkedList temp=head;
	if(current==null){
		System.out.println(&quot;LinkedList is Empty~&quot;);
		return;
	}
	while(current.getNext()!=headNode){
		temp=current;//保存前一个节点
		current=current.getNext();
	}
	current.setNext(null);
	current=null;
	temp.setNext(headNode);
}
</code></pre><h4 id=删除循环链表中的第一个节点>删除循环链表中的第一个节点</h4><p>操作如下：</p><p><img src=/media/20200304-18.png alt=删除循环链表中的第一个节点></p><p>一个代码示例如下：</p><pre><code>void deleteFrontNodeFromCircularLinkedList(CircularLinkedList headNode){
	CircularLinkedList current=headNode;
	if(headNode==null) return;
	while(current.getNext!=headNode){
		current=current.getNext();
	}
	current.setNext(headNode.getNext());
	CircularLinkedList temp=headNode;
	headNode=headNode.getNext();
	temp.setNext(null);
	temp=null;
}
</code></pre></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>P1n93r</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2020-03-02</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/>数据结构与算法</a></div><nav class=post-nav><a class=prev href=/post/other/idea%E4%B9%8Bmaven%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">IDEA之Maven疑难杂症</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/data_tructure/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97/><span class="next-text nav-default">稀疏数组和队列</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname==="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="p1n93r",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:pin83r@gmail.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/p1n93r class="iconfont icon-github" title=github></a>
<a href=https://p1n93r.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次</span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv>本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人</span></div><span class=copyright-year>&copy;
2019 -
2022<span class=heart><i class="iconfont icon-heart"></i></span><span>P1n93r</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js></script></body></html>