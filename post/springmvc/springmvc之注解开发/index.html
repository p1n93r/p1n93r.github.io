<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>SpringMVC之注解开发 - P1n93r - 博学而精一</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="P1n93r"><meta name=description content="前言 之前的一篇博文：SpringMVC之处理器映射器中最后的注解式处理器映射器讲了如何使用最基础的注解开发，现在下面将讨论注解开发中的一些常"><meta name=keywords content="Security,Java,Web,Android"><meta name=generator content="Hugo 0.98.0 with theme even"><link rel=canonical href=https://p1n93r.github.io/post/springmvc/springmvc%E4%B9%8B%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="SpringMVC之注解开发"><meta property="og:description" content="前言 之前的一篇博文：SpringMVC之处理器映射器中最后的注解式处理器映射器讲了如何使用最基础的注解开发，现在下面将讨论注解开发中的一些常"><meta property="og:type" content="article"><meta property="og:url" content="https://p1n93r.github.io/post/springmvc/springmvc%E4%B9%8B%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-07-27T17:48:36+08:00"><meta property="article:modified_time" content="2019-07-27T17:48:36+08:00"><meta itemprop=name content="SpringMVC之注解开发"><meta itemprop=description content="前言 之前的一篇博文：SpringMVC之处理器映射器中最后的注解式处理器映射器讲了如何使用最基础的注解开发，现在下面将讨论注解开发中的一些常"><meta itemprop=datePublished content="2019-07-27T17:48:36+08:00"><meta itemprop=dateModified content="2019-07-27T17:48:36+08:00"><meta itemprop=wordCount content="3346"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="SpringMVC之注解开发"><meta name=twitter:description content="前言 之前的一篇博文：SpringMVC之处理器映射器中最后的注解式处理器映射器讲了如何使用最基础的注解开发，现在下面将讨论注解开发中的一些常"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>P1n93r</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>P1n93r</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>SpringMVC之注解开发</h1><div class=post-meta><span class=post-time>2019-07-27</span><div class=post-category><a href=/categories/springmvc/>SpringMVC</a></div><span class=more-meta>约 3346 字</span>
<span class=more-meta>预计阅读 7 分钟</span>
<span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次阅读</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#讨论对象>讨论对象</a></li><li><a href=#过程>过程</a><ul><li><a href=#requestmapping>@RequestMapping</a></li><li><a href=#控制器返回值>控制器返回值</a></li><li><a href=#参数绑定>参数绑定</a></li></ul></li><li><a href=#结语>结语</a></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=前言>前言</h2><p>  之前的一篇博文：<a href=https://p1n93r.github.io/post/springmvc/springmvc%E4%B9%8B%E6%8E%A7%E5%88%B6%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8/>SpringMVC之处理器映射器</a>中最后的注解式处理器映射器讲了如何使用最基础的注解开发，现在下面将讨论注解开发中的一些常见要点。</p><h2 id=讨论对象>讨论对象</h2><ul><li>@RequestMapping</li><li>控制器返回值</li><li>参数绑定</li></ul><h2 id=过程>过程</h2><h3 id=requestmapping>@RequestMapping</h3><p>  通过之前的利用注解方式配置映射器和适配器，对于控制器中标记有@RequestMapping的方法，我们可以通过@RequestMapping设定的url访问到此方法，其实 <strong>@RequestMapping也可以作用于类上，而不仅仅是作用于方法上</strong> 。作用于类上可以窄化请求映射。注解式开发的控制器都是基于方法的，我们往往把一个模块的控制器都放在一个类里，如果此时用@RequestMapping标记类，窄化此模块的请求，可以很好的起到逻辑上的模块划分的作用。假设我做一个手商城，有一个商品模块，那么是不是可以有商品添加，商品删除，商品修改等等此模块下的控制器，这些控制器放在一个类里，然后我在类前用<code>@RequestMapping("/item")</code>标记，然后假设我的商品添加控制器的标记为<code>@RequestMapping("/addItem")</code>，那么如果我要访问商品添加的控制器，访问的相对url为：<code>/item/addItem</code>，此类里的每个控制器都要加上<code>/item</code>前缀,此所谓窄化了请求。为啥要窄化请求，我认为是可以在逻辑上合理划分模块，一旦控制器多了，有个代表模块的前缀将会使得项目更加合理。参考实例如下：</p><pre><code>@Controller
@RequestMapping(&quot;justTest&quot;)
public class TestController{
    @RequestMapping(&quot;/hello&quot;)
    public ModelAndView sayHello(){
        ModelAndView modelAndView=new ModelAndView(&quot;hello&quot;);
        modelAndView.addObject(&quot;info&quot;,&quot;Hello Man!&quot;);
        return modelAndView;
    }
}
</code></pre><p>  访问测试结果如下：</p><p><img src=/media/%E6%B5%8B%E8%AF%951.png alt=测试1></p><p>  @RequestMapping的另一个要点就是 <strong>请求限制</strong> ，可以规定请求的方式为GET或者POST等等，可以规定请求的提交内容的类型（json等），等等。具体的属性如下表：</p><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>value</td><td>例如 <code>@RequestMapping(value="/test")</code>，其实这等价于 <code>@RequestMapping("/test")</code></td></tr><tr><td>method</td><td>指定请求控制器的方式，有GET，POST，DELETE等。例如：<code>@RequestMapping(value = "/test",method = RequestMethod.POST)</code>就是指定只处理POST类型的请求</td></tr><tr><td>consumes</td><td>规定请求的提交内容的类型，比如我只接受json类型数据的请求，那么我可以设置成： <code>@RequestMapping(value = "/test",consumes = "application/json")</code></td></tr><tr><td>produces</td><td>规定返回的内容的类型，比如我返回xml类型的数据，那么我可以设置成： <code>@RequestMapping(value = "/test",produces = "application/json")</code></td></tr><tr><td>params</td><td>规定请求所必需的带的参数，可以进一步过滤掉无关请求</td></tr><tr><td>headers</td><td>规定请求必须带的HTTP头信息</td></tr></tbody></table><p>  为了测试以上参数，我写的一个控制器如下：</p><pre><code>package com.test.ssm.web.controller;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
@Controller
@RequestMapping(&quot;justTest&quot;)
public class TestController{
    @RequestMapping(
            value=&quot;/hello&quot;,
            params = &quot;id&quot;,
            headers = &quot;Referer=http://p1n93r.github.io/&quot;,
            consumes=&quot;application/XML&quot;,
            produces = &quot;application/JSON&quot;,
            method = RequestMethod.POST
    )
    public void sayHello(HttpServletRequest request, HttpServletResponse response){
        System.out.println(&quot;成功访问到控制器&quot;);
        try {
            PrintWriter out=response.getWriter();
            out.write(&quot;{\&quot;name\&quot;:\&quot;P1n93r\&quot;}&quot;);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>  可以看出，我要求请求带个参数id，并且规定请求头要有<code>Referer=http://p1n93r.github.io/</code>（Referer头一般用来作为网站的同源策略的实现），还规定发送请求的内容类型为xml，还得是POST请求，我返回的内容类型为json类型。然后我用burpsuit发送一个符合规定的HTTP请求，如下图所示：</p><p><img src=/media/%E6%B5%8B%E8%AF%952.png alt=测试2></p><p><em><strong>Notice</strong></em>：虽然我用的POST提交，但是我把请求参数id写在了请求行，还是能被后台识别。</p><h3 id=控制器返回值>控制器返回值</h3><p>注解式控制器的返回值主要有三类：</p><ul><li>ModelAndView</li><li>void</li><li>字符串</li></ul><h4 id=返回modelandview>返回ModelAndView</h4><ul><li>需要开发人员手动实例化ModelAndView对象</li><li>通过调用其实例的 <code>setViewName()</code> 方法来设置返回的逻辑视图名</li><li>通过调用其实例的 <code>addObject()</code> 方法来填充数据</li></ul><h4 id=返回void>返回void</h4><ul><li>其实用法就是普通的Servlet一样的用法</li><li>利用HttpServletRequest对象进行请求转发</li><li>利用HttpServletResponse对象进行重定向或者直接指定响应结果</li></ul><h4 id=返回字符串>返回字符串</h4><ul><li>直接返回一个字符串将被当做逻辑视图名</li><li>字符串以 <code>forward:</code> 打头意思是转发到冒号后面表示的逻辑视图。</li><li>字符串以 <code>redirect</code> 打头意思是重定向到冒号后面表示的逻辑视图。</li></ul><h3 id=参数绑定>参数绑定</h3><p>  所谓的参数绑定就是在HandlerAdapter执行Handler之前，会将HTTP请求的键值对数据绑定在Handler的方法的形参上。用于前后端数据交互。</p><p>  参数绑定支持一些默认的参数类型：HttpServletResponse、HttpServletRequest、HttpSession以及Model/MdelMap。</p><p>  以上默认支持的参数类型，处理器适配器会默认识别并进行赋值。这些除了Model和ModelMap，其实学习javaWeb基础课程时应当是能非常熟练运用了，那就不提了。主要探讨Model/ModelMap的用法，ModelMap是Model接口的实现类，如果我们直接使用Model，SpringMVC会自动实例化ModelMap。ModelMap主要是用于填充数据给前台显示。比如以下的例子，我调用ModelMap的方法 <code>addAtrribute()</code> 来填充数据，前台用EL表达式获取。参考代码如下：</p><pre><code>@Controller
@RequestMapping(&quot;justTest&quot;)
public class TestController{
    @RequestMapping(value=&quot;/hello&quot;)
    public String sayHello(Model model){
        model.addAttribute(&quot;info&quot;,&quot;Welcome to my blog&quot;);
       return  &quot;hello&quot;;
    }
}
</code></pre><p>  hello视图的关键代码为： <code>&lt;h1>${requestScope.info}&lt;/h1></code> ,访问测试结果如下：</p><p><img src=/media/%E6%B5%8B%E8%AF%953.png alt=测试3></p><p>  接下来讨论几种常见的参数绑定场景：</p><ul><li>简单类型</li><li>@RequestParam</li><li>pojo</li><li>集合类</li></ul><h4 id=简单类型参数绑定>简单类型参数绑定</h4><p>  首先说下有哪些简单类型：整形，字符串，布尔型，浮点型。当控制器的形参为这些类型时，如果请求所带的参数名称和控制器的形参名一致时，会将请求参数与形参绑定。一个简单地示例如下：</p><p>控制器代码如下：</p><pre><code>@Controller
@RequestMapping(&quot;justTest&quot;)
public class TestController{
    @RequestMapping(value=&quot;/hello&quot;)
    public String sayHello(Model model,Integer a,String b,Boolean c,Float d,Double e){
        model.addAttribute(&quot;info&quot;,&quot;Welcome to my blog&quot;+&quot;，a:&quot;+a+&quot;,b:&quot;+b+&quot;,c:&quot;+c+&quot;,d:&quot;+d+&quot;,e:&quot;+e);
       return  &quot;hello&quot;;
    }
}
</code></pre><p>测试请求及其结果如下：</p><p><img src=/media/%E6%B5%8B%E8%AF%954.png alt=测试4></p><h4 id=requestparam参数绑定>@RequestParam参数绑定</h4><p>  我们可以用@RequestParam的value属性来映射请求参数，其value为啥，请求发送的参数就得是啥。此外，可以用required属性设定请求发送的参数是否必须有，注意： <strong>如果设定required为false，请求没发送这个参数，那么@RequestParam对应的类型必须为包装类型，否则将报错。</strong> 因为请求没给参数，那么将会给形参赋值为null嘛，int那些简单类型是不能为null的。最后我们可以用defaultValue设定每给参数时的默认值。代码参考如下：</p><pre><code>@Controller
@RequestMapping(&quot;justTest&quot;)
public class TestController{
    @RequestMapping(value=&quot;/hello&quot;)
    public String sayHello(Model model,
                           @RequestParam(value = &quot;what&quot;,required = false,defaultValue = &quot;You said nothing~&quot;)String w){
        model.addAttribute(&quot;info&quot;,&quot;Welcome to my blog&quot;+&quot;&lt;br/&gt;what U say:&quot;+w);
       return  &quot;hello&quot;;
    }
}
</code></pre><p>测试请求及其结果如下：</p><p><img src=/media/%E6%B5%8B%E8%AF%955.png alt=测试5>
<img src=/media/%E6%B5%8B%E8%AF%956.png alt=测试6></p><h4 id=pojo类型参数绑定>pojo类型参数绑定</h4><p>  pojo类型的参数绑定则分为简单pojo和包装型pojo的参数绑定。这里我举例包装型pojo的参数绑定。pojo的代码如下：</p><p>Address类代码：</p><pre><code>package com.test.ssm.pojo;
public class Address {
    private String province;
    private String city;

    //getter and setter
    public String getCity() {
        return city;
    }
    public void setCity(String city) {
        this.city = city;
    }
    public String getProvince() {
        return province;
    }
    public void setProvince(String province) {
        this.province = province;
    }
	@Override
    public String toString() {
        return &quot;Address{&quot; +
                &quot;province='&quot; + province + '\'' +
                &quot;, city='&quot; + city + '\'' +
                '}';
    }
}
</code></pre><p>User类代码：</p><pre><code>package com.test.ssm.pojo;
public class User {
    private String name;
    private int age;
    private Address address;

    //getter and setter
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public Address getAddress() {
        return address;
    }
    public void setAddress(Address address) {
        this.address = address;
    }
    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, address=&quot; + address +
                '}';
    }
}
</code></pre><p>可以看到User类是一个包装的pojo，组合了Address。继续看控制器代码：</p><pre><code>@Controller
@RequestMapping(&quot;justTest&quot;)
public class TestController{
    @RequestMapping(value=&quot;/hello&quot;)
    public String sayHello(Model model, User user){
        model.addAttribute(&quot;info&quot;,&quot;Welcome to my blog&quot;+&quot;&lt;br/&gt;what U say:&quot;+user);
       return  &quot;hello&quot;;
    }
}
</code></pre><p>可以看到，控制器的形参是一个包装类pojo，那么如何参数绑定呢，其实就是发送的请求的参数需要和pojo的属性一致就行了，对于包装型pojo内的简单pojo类型的属性，假设包装型pojo内的简单pojo属性为a，a又有属性b和c，那么请求发送的参数就需要为： <strong>a.b=xx&a.c=XX</strong> 这种形式。根据上面的举例，列出请求测试及其结果：</p><p><img src=/media/%E6%B5%8B%E8%AF%957.png alt=测试7></p><h4 id=集合类参数绑定>集合类参数绑定</h4><p>  集合类主要讨论字符数组，List以及Map。</p><p>  对于字符数组，给出例子如下：</p><pre><code>@Controller
@RequestMapping(&quot;justTest&quot;)
public class TestController{
    @RequestMapping(value=&quot;/hello&quot;)
    public String sayHello(Model model,String[] ss){
        model.addAttribute(&quot;info&quot;,&quot;Welcome to my blog&quot;+&quot;&lt;br/&gt;what U say:&quot;+ss.length);
       return  &quot;hello&quot;;
    }
}
</code></pre><p>发送的请求的参数就是n个ss，例如下图所示：</p><p><img src=/media/%E6%B5%8B%E8%AF%958.png alt=测试8></p><p>  对于List，SpringMVC不能接受前台的数组，所以只能把List封装到一个自定义pojo类对象里（假设被封装的List对象为a，a内的元素类型统一且有属性b和c），然后请求的参数利用a[0].b=xx这种形式来绑定参数。对于Map而言，也是类似，只不过方括号[]内的就不是索引号，而是Map的键名。</p><h2 id=结语>结语</h2><p>  关于注解开发，后面还有验证器，异常处理，文件上传，json数据交互等等重点=-=（好多哇。。。）</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>P1n93r</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2019-07-27</span></p></div><footer class=post-footer><nav class=post-nav><a class=prev href=/post/android/android%E7%9F%A5%E8%AF%86%E7%82%B9x0/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Android知识点x0</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/springmvc/springmvc%D6%AEhello_world/><span class="next-text nav-default">SpringMVC之Hello World</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname==="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="p1n93r",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:pin83r@gmail.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/p1n93r class="iconfont icon-github" title=github></a>
<a href=https://p1n93r.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次</span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv>本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人</span></div><span class=copyright-year>&copy;
2019 -
2022<span class=heart><i class="iconfont icon-heart"></i></span><span>P1n93r</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js></script></body></html>