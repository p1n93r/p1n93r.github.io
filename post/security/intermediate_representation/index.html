<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Intermediate_Representation - P1n93r - 博学而精一</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="P1n93r"><meta name=description content="Intermediate Representation Compilers &amp;amp; Static Analyzers 编译器（Compiler）可以将源码翻译成机器码； 整个翻译过程分为： 词法分析器（Scanner）：使用词法分析（Lexical A"><meta name=keywords content="Security,Java,Web,Android"><meta name=generator content="Hugo 0.98.0 with theme even"><link rel=canonical href=https://p1n93r.github.io/post/security/intermediate_representation/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Intermediate_Representation"><meta property="og:description" content="Intermediate Representation Compilers & Static Analyzers 编译器（Compiler）可以将源码翻译成机器码； 整个翻译过程分为： 词法分析器（Scanner）：使用词法分析（Lexical A"><meta property="og:type" content="article"><meta property="og:url" content="https://p1n93r.github.io/post/security/intermediate_representation/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-05T14:08:52+08:00"><meta property="article:modified_time" content="2022-05-05T14:08:52+08:00"><meta itemprop=name content="Intermediate_Representation"><meta itemprop=description content="Intermediate Representation Compilers & Static Analyzers 编译器（Compiler）可以将源码翻译成机器码； 整个翻译过程分为： 词法分析器（Scanner）：使用词法分析（Lexical A"><meta itemprop=datePublished content="2022-05-05T14:08:52+08:00"><meta itemprop=dateModified content="2022-05-05T14:08:52+08:00"><meta itemprop=wordCount content="3017"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Intermediate_Representation"><meta name=twitter:description content="Intermediate Representation Compilers & Static Analyzers 编译器（Compiler）可以将源码翻译成机器码； 整个翻译过程分为： 词法分析器（Scanner）：使用词法分析（Lexical A"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>P1n93r</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>P1n93r</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Intermediate_Representation</h1><div class=post-meta><span class=post-time>2022-05-05</span>
<span class=more-meta>约 3017 字</span>
<span class=more-meta>预计阅读 7 分钟</span>
<span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次阅读</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#intermediate-representation>Intermediate Representation</a></li><li><a href=#compilers--static-analyzers>Compilers & Static Analyzers</a></li><li><a href=#ast-vs-ir>AST vs IR</a></li><li><a href=#ir-three-address-code3ac>IR: Three-Address Code(3AC)</a><ul><li><a href=#3-address-code3ac>3-Address Code(3AC)</a></li><li><a href=#一些常见的3ac形式>一些常见的3AC形式</a></li></ul></li><li><a href=#3ac-in-real-static-analyzer>3AC in Real Static Analyzer</a><ul><li><a href=#soot的ir-jimple>Soot的IR: Jimple</a></li></ul></li><li><a href=#static-single-assignmentssa>Static Single Assignment(SSA)</a></li><li><a href=#control-flow-analysis>Control Flow Analysis</a></li><li><a href=#basic-blocksbb>Basic Blocks(BB)</a></li><li><a href=#control-flow-graphscfg>Control Flow Graphs(CFG)</a></li></ul></nav></div></div><div class=post-content><h1 id=intermediate-representation>Intermediate Representation</h1><h1 id=compilers--static-analyzers>Compilers & Static Analyzers</h1><p>编译器（Compiler）可以将源码翻译成机器码； 整个翻译过程分为：</p><ol><li>词法分析器（Scanner）：使用词法分析（Lexical Analysis）根据正则表达式（Regualar Expression）进行分析，如果检查通过则生成Tokens；</li><li>语法分析器（Parser）：使用语法分析（Syntax Analysis）根据上下文无关文法（Context-Free Grammar）进行分析，如果检查通过则生成AST（抽象语法树）；</li><li>语义分析器（Type Checker）：使用语义分析（Semantic Analysis）根据属性文法（Attribute Grammar）进行分析，如果检查通过则生成Decorated AST；</li><li>转换器（Translator）：将Decorated AST转换为IR（Intermediate Representation），通常为三地址码（3AC，3 Address Code），静态程序分析通常会将IR转换为CFG（Controll Flow Graph）进行下一步分析；</li><li>代码生成器（Code Generator）：经过优化后，将IR生成机器码（Machine Code）；</li></ol><p>图示如下所示：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-0-1731743.png alt=Untitled></p><h1 id=ast-vs-ir>AST vs IR</h1><p>针对一段代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>do i = i+1; while(a[i]&lt;v);
</span></span></code></pre></td></tr></table></div></div><p>写出其AST和IR的表现形式，AST表现形式：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-1-1731743.png alt=Untitled></p><p>IR表现形式：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-2-1731743.png alt=Untitled></p><p>很明显的可以看出两者的区别：</p><p>（1）AST的特性：</p><ul><li>high-level并且贴合Grammar Structure；</li><li>通常依赖不同的语言；</li><li>适用于快速类型检查；</li><li>缺少控制流信息；</li></ul><p>（2）IR的特性：</p><ul><li>low-level并且贴合机器码（和汇编很像）；</li><li>通常不依赖于语言（于此便可以使用不同的前端，把不同的Source Code翻译成统一的IR）；</li><li>结构比较紧凑和均匀；</li><li>包含控制流信息；</li><li>通常被认为是静态程序分析的基础；</li></ul><h1 id=ir-three-address-code3ac>IR: Three-Address Code(3AC)</h1><h2 id=3-address-code3ac>3-Address Code(3AC)</h2><p>三地址码（3AC）的特征：一条指令的右侧最多有一个运算符，每一个3AC最多包含3个address，每种类型的指令都有对应的3AC；</p><p>例如如下语句：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>t2 = a + b + 3
</span></span></code></pre></td></tr></table></div></div><p>将其转换成3AC：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>t1 = a + b
</span></span><span class=line><span class=cl>t2 = t1 + 3
</span></span></code></pre></td></tr></table></div></div><p>对于如上的3AC中，其对应的address如下，每个指令的address都没超过3个：</p><ul><li>Name: a , b</li><li>Constant: 3</li><li>Compiler-generated temporary: t1, t2</li></ul><h2 id=一些常见的3ac形式>一些常见的3AC形式</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>x = y bop z
</span></span><span class=line><span class=cl>x = uop y
</span></span><span class=line><span class=cl>x = y
</span></span><span class=line><span class=cl>goto L
</span></span><span class=line><span class=cl>if x goto L
</span></span><span class=line><span class=cl>if x rop y goto L
</span></span></code></pre></td></tr></table></div></div><p>对应上面的一些符号解释如下：</p><ul><li>x, y, z：addresses</li><li>bop：二进制算术或逻辑运算</li><li>uop：一元运算（减号、取反、强制转换）</li><li>L：表示程序位置的标签</li><li>rop：关系运算符（>、&lt;、==、>=、&lt;= 等）</li><li>goto L：无条件跳转</li><li>if &mldr; goto L：条件跳转</li></ul><h1 id=3ac-in-real-static-analyzer>3AC in Real Static Analyzer</h1><h2 id=soot的ir-jimple>Soot的IR: Jimple</h2><p>Soot是一个流行的Java静态程序分析框架，一些资料如下：</p><ul><li><a href=https://github.com/Sable/soot>https://github.com/Sable/soot</a></li><li><a href=https://github.com/Sable/soot/wiki/Tutorials>https://github.com/Sable/soot/wiki/Tutorials</a></li></ul><p>Soot的IR（Intermediate Representation）叫做Jimper，也是三地址码形式（3AC）；</p><p>（1）例如如下do&mldr;while循环代码（Java Source Code）：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-3-1731743.png alt=Untitled></p><p>翻译成Jimper的形式：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-4-1731743.png alt=Untitled></p><p>（2）例如如下的函数调用（Method Call）代码：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-5-1731743.png alt=Untitled></p><p>翻译成Jimper的形式（foo函数）：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-6-1731743.png alt=Untitled></p><p>翻译成Jimper的形式（main函数）：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-7-1731743.png alt=Untitled></p><p>（3）例如如下类（Class）代码：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-8-1731743.png alt=Untitled></p><p>翻译成Jimper的形式：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-9-1731743.png alt=Untitled></p><h1 id=static-single-assignmentssa>Static Single Assignment(SSA)</h1><p>这一部分李老师说是选学部分，比较老，但是比较经典，这部分紧紧作为普及；SSA即为静态单一分配（Static Single Assignment）；</p><p>SSA 中的所有赋值都是有不同名称的变量，详细解释如下：</p><ul><li>每个定义需要给定一个新的名字；</li><li>将新名称传播给后续使用；</li><li>每个变量都只有一个定义；</li></ul><p>例如如下图是SSA的具体形式（左边是3AC，右边是SSA）：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-10-1731743.png alt=Untitled></p><p>既然每个变量只有一个定义，那么如果遇到了control flow merges，该如何处理？例如如下是一个control flow merges，x现在不确定到底是x0还是x1：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-11-1731743.png alt=Untitled></p><p>如果是SSA，那么就会引入一个**<code>∅</code>** 方法，这个方法用于在merge节点时进行值选择，**<code>∅**(x0, x1)</code> 操作中，如果控制流传递true条件，则选择x0，反之亦反；例如如上的例子，经过SSA的处理，会变成如下形式：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-12-1731743.png alt=Untitled></p><p>（1）为啥使用SSA：</p><ul><li>流量信息被间接纳入唯一的变量名：可能有助于提供一些更简单的分析，例如，非敏感数据流分析可以通过SSA增强部分敏感数据流分析的精度；</li><li>Define-and-Use pairs是显式的：实现更有效的数据facts存储和传播一些按需任务；一些优化任务在 SSA 上表现更好（例如，条件常数传播，全局值编号）</li></ul><p>（2）为啥不使用SSA：</p><ul><li>SSA可能会引入过多的phi函数；</li><li>翻译成机器码时可能会存在效率低下的问题（因为复制操作）；</li></ul><h1 id=control-flow-analysis>Control Flow Analysis</h1><ul><li>通常指的是创建控制流图（CFG，Control Flow Graph）；</li><li>CFG 是静态程序分析的基本结构；</li><li>CFG 中的节点可以是单独的3地址码，或（通常）基本块（BB，Basic Block）；</li></ul><p>一个将3地址码转换为CFG的图示如下：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-13-1731743.png alt=Untitled></p><h1 id=basic-blocksbb>Basic Blocks(BB)</h1><p>BB（Basic Blocks）是最大的连续的3地址码，且这个最大的连续3地址码存在如下性质：</p><ul><li>只能在开头输入，例如block中的第一条指令；</li><li>只能在结尾退出，例如block中的最后一条指令；</li></ul><p>图示如下：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-14-1731743.png alt=Untitled></p><p>计算一个程序中的连续3AC的Basic Blocks的算法如下：</p><ul><li>程序P的第一条指令是一个leader；</li><li>有条件跳转、无条件跳转的目标指令是一个leader（确保唯一出口）；</li><li>有条件跳转、无条件跳转紧接着的下一条指令是一个leader；</li><li>一个BB就是一个leader到下一个leader之前的所有指令；</li></ul><p>接下来看到一个例子，如下程序的3AC：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(10) if p == q goto (12)
</span></span><span class=line><span class=cl>(8) b = x + a
</span></span><span class=line><span class=cl>(9) c = 2a - b
</span></span><span class=line><span class=cl>(1) x = input
</span></span><span class=line><span class=cl>(2) y = x - 1
</span></span><span class=line><span class=cl>(3) z = x * y
</span></span><span class=line><span class=cl>(4) if z &lt; x goto (7)
</span></span><span class=line><span class=cl>(5) p = x / y
</span></span><span class=line><span class=cl>(6) q = p + y
</span></span><span class=line><span class=cl>(7) a = q
</span></span><span class=line><span class=cl>(11) goto (3)
</span></span><span class=line><span class=cl>(12) return
</span></span></code></pre></td></tr></table></div></div><p>首先我们需要识别出程序中的所有leader；看到前面算法，知道程序的第一条指令就是一个leader，所以目前已知leader：(1) ；</p><p>然后跳转指令的目标指令是leader，那么就知道存在这些leader：(3)、(7)、(12)；</p><p>最后跳转指令紧接着的下一条指令也是leader，那么就知道存在如下leader：(5)、(11)、(12)；</p><p>总而言之，现在的leader有：(1)、(3)、(7)、(12)、(5)、(11)、(12)，那么根据“一个BB就是一个leader到下一个leader之前的所有指令”可以得到所有的BB如下：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-15-1731743.png alt=Untitled></p><p>也就是：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-16-1731743.png alt=Untitled></p><h1 id=control-flow-graphscfg>Control Flow Graphs(CFG)</h1><p>控制流图（CFG）存在如下性质：</p><ul><li>CFG的节点都是一些BB（Basic Blocks）；</li><li>块A到块B之间如果存在边（Edge），需要满足条件：（1）块A的最后一条指令是条件/无条件跳转指令，并且跳转指令的目标是块B的第一条指令；（2）当块A和块B顺序上是紧紧连着的，此时如果块A的最后一条指令是无条件跳转指令，即使跳转指令的目标指令在块B内，块A和块B之间也不应该存在边（Edge）；</li></ul><p>图示如下：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-17-1731743.png alt=Untitled></p><p>根据图示其实也就很自然的会把跳转的Label替换成BB，也就是将上图变成下面的样子，把一个BB看做一个单元：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-18-1731743.png alt=Untitled></p><p>使用Edge按照前面说的规则将BB连接起来后，通常还会添加两个节点：Entry和Exit；关于这两个节点的性质如下：</p><ul><li>它们不对应于可执行的 IR；</li><li>Entry存在一条Edge指向一个BB，这个BB包含整个IR的第一条指令，也就是这个BB是整个程序的第一个BB；</li><li>某个BB存在一条Edge指向Exit，这个BB包含整个IR的最后一条指令，也就是这个BB是整个程序的最后一个BB；</li></ul><p>图示如下：</p><p><img src=/media/28940079-a514-4b3e-afb7-74ccbc917698-19-1731743.png alt=Untitled></p></div><footer class=post-footer><nav class=post-nav><a class=prev href=/post/security/data_flow_analysis/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Data_Flow_Analysis</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/security/souffle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><span class="next-text nav-default">Souffle学习笔记</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:pin83r@gmail.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/p1n93r class="iconfont icon-github" title=github></a>
<a href=https://p1n93r.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次</span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv>本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人</span></div><span class=copyright-year>&copy;
2019 -
2022<span class=heart><i class="iconfont icon-heart"></i></span><span>P1n93r</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js></script></body></html>