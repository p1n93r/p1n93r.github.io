<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Interprocedural_Analysis - P1n93r - 博学而精一</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="P1n93r"><meta name=description content="Interprocedural Analysis Motivation 到目前为止，我们学习的分析都是程序内分析（Intraprocedural），这种分析是不处理方法调用的，如果碰到了方法调用，基于Inr"><meta name=keywords content="Security,Java,Web,Android"><meta name=generator content="Hugo 0.98.0 with theme even"><link rel=canonical href=https://p1n93r.github.io/post/security/interprocedural_analysis/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Interprocedural_Analysis"><meta property="og:description" content="Interprocedural Analysis Motivation 到目前为止，我们学习的分析都是程序内分析（Intraprocedural），这种分析是不处理方法调用的，如果碰到了方法调用，基于Inr"><meta property="og:type" content="article"><meta property="og:url" content="https://p1n93r.github.io/post/security/interprocedural_analysis/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-06T14:43:04+08:00"><meta property="article:modified_time" content="2022-05-06T14:43:04+08:00"><meta itemprop=name content="Interprocedural_Analysis"><meta itemprop=description content="Interprocedural Analysis Motivation 到目前为止，我们学习的分析都是程序内分析（Intraprocedural），这种分析是不处理方法调用的，如果碰到了方法调用，基于Inr"><meta itemprop=datePublished content="2022-05-06T14:43:04+08:00"><meta itemprop=dateModified content="2022-05-06T14:43:04+08:00"><meta itemprop=wordCount content="2810"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Interprocedural_Analysis"><meta name=twitter:description content="Interprocedural Analysis Motivation 到目前为止，我们学习的分析都是程序内分析（Intraprocedural），这种分析是不处理方法调用的，如果碰到了方法调用，基于Inr"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>P1n93r</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>P1n93r</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Interprocedural_Analysis</h1><div class=post-meta><span class=post-time>2022-05-06</span>
<span class=more-meta>约 2810 字</span>
<span class=more-meta>预计阅读 6 分钟</span>
<span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次阅读</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#interprocedural-analysis>Interprocedural Analysis</a></li><li><a href=#motivation>Motivation</a></li><li><a href=#call-graph-constructioncha>Call Graph Construction(CHA)</a><ul><li><a href=#method-callsinvocations-in-java>Method Calls(Invocations) in Java</a></li><li><a href=#method-dispatch-of-virtual-calls>Method Dispatch of Virtual Calls</a></li><li><a href=#class-hierarchy-analysischa>Class Hierarchy Analysis(CHA)</a></li><li><a href=#features-of-cha>Features of CHA</a></li><li><a href=#call-graph-construction>Call Graph Construction</a></li></ul></li><li><a href=#interprocedural-control-flow-graph>Interprocedural Control-Flow Graph</a></li><li><a href=#interprocedural-data-flow-analysis>Interprocedural Data-Flow Analysis</a><ul><li><a href=#interprocedural-constant-propagation>Interprocedural Constant Propagation</a></li></ul></li></ul></nav></div></div><div class=post-content><h1 id=interprocedural-analysis>Interprocedural Analysis</h1><h1 id=motivation>Motivation</h1><p>到目前为止，我们学习的分析都是程序内分析（Intraprocedural），这种分析是不处理方法调用的，如果碰到了方法调用，基于Inraprocedural的分析是如何处理的呢？例如存在如下程序（常量传播，Constant Propagation）：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-0.png alt=Untitled></p><p>Inraprocedural analysis为了safe-approximation会采用最保守的假设，也就是假设方法调用可以做任何事情，基于这种过于保守的假设，在Inraprocedural analysis下，会认为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>n = NAC
</span></span><span class=line><span class=cl>x = NAC, y = NAC
</span></span></code></pre></td></tr></table></div></div><p>所以可以看到，如果使用Inraprocedural anlysis处理过程调用（method calls），那么就会丢失很多精度（imprecesion），为了更准确的精度，我们需要过程间分析（Interprocedural analysis），过程间分析会沿着过程间的控制流edges进行数据流传播，使用过程间分析，对于上面的常量传播实例程序，可以得到：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>x = 42, y = 43
</span></span><span class=line><span class=cl>n = 10
</span></span></code></pre></td></tr></table></div></div><p>所谓过程间的控制流edges的图示如下：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-1.png alt=Untitled></p><p>同时，为了更好的过程间分析，我们需要call graph；</p><h1 id=call-graph-constructioncha>Call Graph Construction(CHA)</h1><p>call graph的定义：call graph即为程序中调用关系的表示，本质上，call graph是一组从call-sites到他们的目标方法的调用边（call edges），call-sites的目标方法称为（callees）；</p><p>如下是call graph的图示：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-2.png alt=Untitled></p><p>call graph是过程间分析的基础，是非常重要的程序信息；对于调用图构建比较有代表性的集中算法如下，越往上，速度越快，但是精度越低，越往下速度越慢，但是精度越高。我们主要学习的就是CHA和k-CFA算法：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-3.png alt=Untitled></p><h2 id=method-callsinvocations-in-java>Method Calls(Invocations) in Java</h2><p>对于Java而言，其函数调用可以分析如下三种，其中Virtual Call主要应用于多态，因为多态，其目标方法只能在运行时确定；在Java中，认为除了静态方法、构造方法、私有方法和父类方法，其他的都为Virtual Call；</p><p>一个用于描述Java中的方法调用的表格如下：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-4.png alt=Untitled></p><p>其中的Virtual Call对于OOPLs（面向对象程序语言）的call graph construction非常关键；</p><h2 id=method-dispatch-of-virtual-calls>Method Dispatch of Virtual Calls</h2><p>在运行时，一个virtual call的解析主要取决于：</p><ol><li>receiver object的type；</li><li>call site的方法签名（method signature）；</li></ol><p>我们暂且认为方法签名由以下部分组成：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Signature = class type + method name + descriptor
</span></span><span class=line><span class=cl>Descriptor = return type + parameter types
</span></span></code></pre></td></tr></table></div></div><p>图示如下：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-5.png alt=Untitled></p><p>最后我们可以定义一个 <code>Dispatch(c, m)</code> 方法来模拟运行时call-site具体方法的调用；算法如下：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-6.png alt=Untitled></p><p>其中，c指的是receiver object的true type，而m指的是call site的方法的签名；对于这个Dispatch方法而言，这个call site的方法签名中，class type指的是declared type；</p><p>一个使用案例如下：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-7.png alt=Untitled></p><h2 id=class-hierarchy-analysischa>Class Hierarchy Analysis(CHA)</h2><ul><li>CHA即为类层次结构分析算法，对于这种算法，它需要知道程序中类的继承结构信息（hierarchy information），例如需要知道某个类的父类和子类有哪些；</li><li>CHA的主要思想就是在一个call site中，根据receiver variable的desclared type计算virtual call；</li><li>CHA假设变量a可以指向类A以及类A的所有子类的对象，所以CHA计算目标方法的过程就是查询类A的整个继承结构来查询目标方法；</li><li>CHA算法是1995年在ECOOP会议上首次发表出来的；</li></ul><p>如下是CHA的一个具体算法，其中的cs指的是call site：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-8.png alt=Untitled></p><p>根据这个算法进行一个案例计算，图示如下：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-9.png alt=Untitled></p><h2 id=features-of-cha>Features of CHA</h2><p>CHA的优势是速度快，原因如下：</p><ul><li>只考虑call site中receiver variable的declared type和它的继承结构；</li><li>忽略数据流和控制流信息；</li></ul><p>CHA的劣势是精度较低，原因如下：</p><ul><li>容易引入虚假目标方法；</li><li>没有使用指针分析；</li></ul><h2 id=call-graph-construction>Call Graph Construction</h2><p>通过CHA算法生成call graph的步骤如下：</p><ul><li>从入口方法开始（例如对于Java而言的main方法）；</li><li>对于每一个可达方法m，在方法m中通过CHA算法为每一个call site计算目标方法；</li><li>重复这个过程直到没有新的方法被发现；</li></ul><p>图示如下所示，灰色的部分就是代表不可达的方法：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-10.png alt=Untitled></p><p>具体的算法如下：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-11.png alt=Untitled></p><p>一个使用CHA构建call graph的演算案例如下：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-12.png alt=Untitled></p><h1 id=interprocedural-control-flow-graph>Interprocedural Control-Flow Graph</h1><ul><li>CFG 表示单个方法的结构；</li><li>而ICFG表示整个程序的结构，基于ICFG，我们可以进行过程间（Interprocedural）分析；</li><li>ICFG由程序中各个方法的CFG组成，但是还需要再多添加两条额外的边：Call edges和Return edges；</li><li>Call edges指的就是：从call sites指向其被调用方法（callees）内部节点的edges；</li><li>Return edges指的就是：从被调用方法的exit节点指向与之对应的call site紧接着的下一个statement；</li><li>连接Call edges和Return edges两种类型的边的信息，来自于call graph；</li></ul><p>总结一下，就是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ICFG = CFGs + call &amp; return edges
</span></span></code></pre></td></tr></table></div></div><p>一个ICFG案例如下（基于值传递，非指针传递）：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-13.png alt=Untitled></p><p>这里需要注意黄色标记的call-to-return edge，既然数据流可以从return edge往下连接起来，为啥还需要存在call-to-return edge？因为如果不保留call-to-return edge，那么就需要在callee中维护与实参无关的数据传播；有了call-to-return edge，那么与实参无关的数据就可以通过这条边直接传递下去了，无需经过callee；</p><h1 id=interprocedural-data-flow-analysis>Interprocedural Data-Flow Analysis</h1><p>之前我们基于CFG进行数据流分析，其transfer functions主要是node transfer，而基于ICDF（过程间控制流图，Interprocedural Control Flow Graph）进行数据流分析，其transfer functions主要是node transfer加上edge transfer；</p><p>edge transfer主要分为如下两种：</p><ul><li>call edge transfer：沿着call edge，将来自于call site的数据流转换到callee中的节点；</li><li>return edge transfer：沿着return ege，将来自于callee的exit节点的数据流转换到return site；</li></ul><h2 id=interprocedural-constant-propagation>Interprocedural Constant Propagation</h2><ul><li>Call edge transfer：传递参数值；</li><li>Return edge transfer：传递返回值；</li><li>Node transfer：和过程内的常量传播一致，但是如果是call nodes，transfer function就是一个特殊的function；</li></ul><p>对于Interprocedural Constant Propagation的call node transfer，它会杀死这个node的左边的变量，把左边的变量的数据流处理交给edge transfer，图示如下：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-14.png alt=Untitled></p><p>对于call node transfer的一个更加直观的图示，画×部分代表b变量被kill了，但是后面经过return edge transfer还是把b变量传播下来了，并且没有丢失精度：</p><p><img src=/media/2a88c9e8-8112-4213-9d80-422582df98c0-15.png alt=Untitled></p></div><footer class=post-footer><nav class=post-nav><a class=next href=/post/security/data_flow_analysis/><span class="next-text nav-default">Data_Flow_Analysis</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:pin83r@gmail.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/p1n93r class="iconfont icon-github" title=github></a>
<a href=https://p1n93r.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次</span>
<span class=division>|</span>
<span id=busuanzi_container_site_uv>本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人</span></div><span class=copyright-year>&copy;
2019 -
2022<span class=heart><i class="iconfont icon-heart"></i></span><span>P1n93r</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js></script></body></html>